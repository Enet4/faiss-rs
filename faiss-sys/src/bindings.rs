/* automatically generated by rust-bindgen 0.69.4 */

pub type faiss_idx_t = i64;
pub type idx_t = faiss_idx_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissRangeSearchResult_H {
    _unused: [u8; 0],
}
pub type FaissRangeSearchResult = FaissRangeSearchResult_H;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIDSelector_H {
    _unused: [u8; 0],
}
pub type FaissIDSelector = FaissIDSelector_H;
#[doc = "< maximum inner product search"]
pub const FaissMetricType_METRIC_INNER_PRODUCT: FaissMetricType = 0;
#[doc = "< squared L2 search"]
pub const FaissMetricType_METRIC_L2: FaissMetricType = 1;
#[doc = "< L1 (aka cityblock)"]
pub const FaissMetricType_METRIC_L1: FaissMetricType = 2;
#[doc = "< infinity distance"]
pub const FaissMetricType_METRIC_Linf: FaissMetricType = 3;
#[doc = "< L_p distance, p is given by metric_arg"]
pub const FaissMetricType_METRIC_Lp: FaissMetricType = 4;
#[doc = " some additional metrics defined in scipy.spatial.distance"]
pub const FaissMetricType_METRIC_Canberra: FaissMetricType = 20;
#[doc = " some additional metrics defined in scipy.spatial.distance"]
pub const FaissMetricType_METRIC_BrayCurtis: FaissMetricType = 21;
#[doc = " some additional metrics defined in scipy.spatial.distance"]
pub const FaissMetricType_METRIC_JensenShannon: FaissMetricType = 22;
#[doc = " Some algorithms support both an inner product version and a L2 search\n version."]
pub type FaissMetricType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissSearchParameters_H {
    _unused: [u8; 0],
}
pub type FaissSearchParameters = FaissSearchParameters_H;
extern "C" {
    pub fn faiss_SearchParameters_free(obj: *mut FaissSearchParameters);
}
extern "C" {
    pub fn faiss_SearchParameters_new(
        p_sp: *mut *mut FaissSearchParameters,
        sel: *mut FaissIDSelector,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIndex_H {
    _unused: [u8; 0],
}
pub type FaissIndex = FaissIndex_H;
extern "C" {
    pub fn faiss_Index_free(obj: *mut FaissIndex);
}
extern "C" {
    pub fn faiss_Index_d(arg1: *const FaissIndex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Index_is_trained(arg1: *const FaissIndex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Index_ntotal(arg1: *const FaissIndex) -> idx_t;
}
extern "C" {
    pub fn faiss_Index_metric_type(arg1: *const FaissIndex) -> FaissMetricType;
}
extern "C" {
    pub fn faiss_Index_verbose(arg1: *const FaissIndex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Index_set_verbose(arg1: *mut FaissIndex, arg2: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Perform training on a representative set of vectors\n\n @param index  opaque pointer to index object\n @param n      nb of training vectors\n @param x      training vectors, size n * d"]
    pub fn faiss_Index_train(
        index: *mut FaissIndex,
        n: idx_t,
        x: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add n vectors of dimension d to the index.\n\n Vectors are implicitly assigned labels ntotal .. ntotal + n - 1\n This function slices the input vectors in chunks smaller than\n blocksize_add and calls add_core.\n @param index  opaque pointer to index object\n @param x      input matrix, size n * d"]
    pub fn faiss_Index_add(
        index: *mut FaissIndex,
        n: idx_t,
        x: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Same as add, but stores xids instead of sequential ids.\n\n The default implementation fails with an assertion, as it is\n not supported by all indexes.\n\n @param index  opaque pointer to index object\n @param xids   if non-null, ids to store for the vectors (size n)"]
    pub fn faiss_Index_add_with_ids(
        index: *mut FaissIndex,
        n: idx_t,
        x: *const f32,
        xids: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " query n vectors of dimension d to the index.\n\n return at most k vectors. If there are not enough results for a\n query, the result array is padded with -1s.\n\n @param index       opaque pointer to index object\n @param x           input vectors to search, size n * d\n @param labels      output labels of the NNs, size n*k\n @param distances   output pairwise distances, size n*k"]
    pub fn faiss_Index_search(
        index: *const FaissIndex,
        n: idx_t,
        x: *const f32,
        k: idx_t,
        distances: *mut f32,
        labels: *mut idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " query n vectors of dimension d with search parameters to the index.\n\n return at most k vectors. If there are not enough results for a query,\n the result is padded with -1s.\n\n @param index       opaque pointer to index object\n @param x           input vectors to search, size n * d\n @param params      input params to modify how search is done\n @param labels      output labels of the NNs, size n*k\n @param distances   output pairwise distances, size n*k"]
    pub fn faiss_Index_search_with_params(
        index: *const FaissIndex,
        n: idx_t,
        x: *const f32,
        k: idx_t,
        params: *const FaissSearchParameters,
        distances: *mut f32,
        labels: *mut idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " query n vectors of dimension d to the index.\n\n return all vectors with distance < radius. Note that many\n indexes do not implement the range_search (only the k-NN search\n is mandatory).\n\n @param index       opaque pointer to index object\n @param x           input vectors to search, size n * d\n @param radius      search radius\n @param result      result table"]
    pub fn faiss_Index_range_search(
        index: *const FaissIndex,
        n: idx_t,
        x: *const f32,
        radius: f32,
        result: *mut FaissRangeSearchResult,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " return the indexes of the k vectors closest to the query x.\n\n This function is identical as search but only return labels of neighbors.\n @param index       opaque pointer to index object\n @param x           input vectors to search, size n * d\n @param labels      output labels of the NNs, size n*k"]
    pub fn faiss_Index_assign(
        index: *mut FaissIndex,
        n: idx_t,
        x: *const f32,
        labels: *mut idx_t,
        k: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " removes all elements from the database.\n @param index       opaque pointer to index object"]
    pub fn faiss_Index_reset(index: *mut FaissIndex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " removes IDs from the index. Not supported by all indexes\n @param index       opaque pointer to index object\n @param nremove     output for the number of IDs removed"]
    pub fn faiss_Index_remove_ids(
        index: *mut FaissIndex,
        sel: *const FaissIDSelector,
        n_removed: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reconstruct a stored vector (or an approximation if lossy coding)\n\n this function may not be defined for some indexes\n @param index       opaque pointer to index object\n @param key         id of the vector to reconstruct\n @param recons      reconstructed vector (size d)"]
    pub fn faiss_Index_reconstruct(
        index: *const FaissIndex,
        key: idx_t,
        recons: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reconstruct vectors i0 to i0 + ni - 1\n\n this function may not be defined for some indexes\n @param index       opaque pointer to index object\n @param recons      reconstructed vector (size ni * d)"]
    pub fn faiss_Index_reconstruct_n(
        index: *const FaissIndex,
        i0: idx_t,
        ni: idx_t,
        recons: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Computes a residual vector after indexing encoding.\n\n The residual vector is the difference between a vector and the\n reconstruction that can be decoded from its representation in\n the index. The residual can be used for multiple-stage indexing\n methods, like IndexIVF's methods.\n\n @param index       opaque pointer to index object\n @param x           input vector, size d\n @param residual    output residual vector, size d\n @param key         encoded index, as returned by search and assign"]
    pub fn faiss_Index_compute_residual(
        index: *const FaissIndex,
        x: *const f32,
        residual: *mut f32,
        key: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Computes a residual vector after indexing encoding.\n\n The residual vector is the difference between a vector and the\n reconstruction that can be decoded from its representation in\n the index. The residual can be used for multiple-stage indexing\n methods, like IndexIVF's methods.\n\n @param index       opaque pointer to index object\n @param n           number of vectors\n @param x           input vector, size (n x d)\n @param residuals    output residual vectors, size (n x d)\n @param keys         encoded index, as returned by search and assign"]
    pub fn faiss_Index_compute_residual_n(
        index: *const FaissIndex,
        n: idx_t,
        x: *const f32,
        residuals: *mut f32,
        keys: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The size of the produced codes in bytes.\n\n @param index   opaque pointer to index object\n @param size    the returned size in bytes"]
    pub fn faiss_Index_sa_code_size(
        index: *const FaissIndex,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " encode a set of vectors\n\n @param index   opaque pointer to index object\n @param n       number of vectors\n @param x       input vectors, size n * d\n @param bytes   output encoded vectors, size n * sa_code_size()"]
    pub fn faiss_Index_sa_encode(
        index: *const FaissIndex,
        n: idx_t,
        x: *const f32,
        bytes: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " decode a set of vectors\n\n @param index   opaque pointer to index object\n @param n       number of vectors\n @param bytes   input encoded vectors, size n * sa_code_size()\n @param x       output vectors, size n * d"]
    pub fn faiss_Index_sa_decode(
        index: *const FaissIndex,
        n: idx_t,
        bytes: *const u8,
        x: *mut f32,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissParameterRange_H {
    _unused: [u8; 0],
}
pub type FaissParameterRange = FaissParameterRange_H;
extern "C" {
    pub fn faiss_ParameterRange_name(
        arg1: *const FaissParameterRange,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Getter for the values in the range. The output values are invalidated\n upon any other modification of the range."]
    pub fn faiss_ParameterRange_values(
        arg1: *mut FaissParameterRange,
        arg2: *mut *mut f64,
        arg3: *mut usize,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissParameterSpace_H {
    _unused: [u8; 0],
}
pub type FaissParameterSpace = FaissParameterSpace_H;
extern "C" {
    pub fn faiss_ParameterSpace_free(obj: *mut FaissParameterSpace);
}
extern "C" {
    #[doc = " Parameter space default constructor"]
    pub fn faiss_ParameterSpace_new(space: *mut *mut FaissParameterSpace) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " nb of combinations, = product of values sizes"]
    pub fn faiss_ParameterSpace_n_combinations(arg1: *const FaissParameterSpace) -> usize;
}
extern "C" {
    #[doc = " get string representation of the combination\n by writing it to the given character buffer.\n A buffer size of 1000 ensures that the full name is collected."]
    pub fn faiss_ParameterSpace_combination_name(
        arg1: *const FaissParameterSpace,
        arg2: usize,
        arg3: *mut ::std::os::raw::c_char,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " set a combination of parameters described by a string"]
    pub fn faiss_ParameterSpace_set_index_parameters(
        arg1: *const FaissParameterSpace,
        arg2: *mut FaissIndex,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " set a combination of parameters on an index"]
    pub fn faiss_ParameterSpace_set_index_parameters_cno(
        arg1: *const FaissParameterSpace,
        arg2: *mut FaissIndex,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " set one of the parameters"]
    pub fn faiss_ParameterSpace_set_index_parameter(
        arg1: *const FaissParameterSpace,
        arg2: *mut FaissIndex,
        arg3: *const ::std::os::raw::c_char,
        arg4: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " print a description on stdout"]
    pub fn faiss_ParameterSpace_display(arg1: *const FaissParameterSpace);
}
extern "C" {
    #[doc = " add a new parameter (or return it if it exists)"]
    pub fn faiss_ParameterSpace_add_range(
        arg1: *mut FaissParameterSpace,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut FaissParameterRange,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Class for the clustering parameters. Can be passed to the\n constructor of the Clustering object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissClusteringParameters {
    #[doc = "< clustering iterations"]
    pub niter: ::std::os::raw::c_int,
    #[doc = "< redo clustering this many times and keep best"]
    pub nredo: ::std::os::raw::c_int,
    #[doc = "< (bool)"]
    pub verbose: ::std::os::raw::c_int,
    #[doc = "< (bool) do we want normalized centroids?"]
    pub spherical: ::std::os::raw::c_int,
    #[doc = "< (bool) round centroids coordinates to integer"]
    pub int_centroids: ::std::os::raw::c_int,
    #[doc = "< (bool) update index after each iteration?"]
    pub update_index: ::std::os::raw::c_int,
    #[doc = "< (bool) use the centroids provided as input and do\n< not change them during iterations"]
    pub frozen_centroids: ::std::os::raw::c_int,
    #[doc = "< otherwise you get a warning"]
    pub min_points_per_centroid: ::std::os::raw::c_int,
    #[doc = "< to limit size of dataset"]
    pub max_points_per_centroid: ::std::os::raw::c_int,
    #[doc = "< seed for the random number generator"]
    pub seed: ::std::os::raw::c_int,
    #[doc = "< how many vectors at a time to decode"]
    pub decode_block_size: usize,
}
#[test]
fn bindgen_test_layout_FaissClusteringParameters() {
    const UNINIT: ::std::mem::MaybeUninit<FaissClusteringParameters> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FaissClusteringParameters>(),
        48usize,
        concat!("Size of: ", stringify!(FaissClusteringParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<FaissClusteringParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(FaissClusteringParameters))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).niter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(niter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nredo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(nredo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verbose) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(verbose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spherical) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(spherical)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_centroids) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(int_centroids)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update_index) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(update_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frozen_centroids) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(frozen_centroids)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_points_per_centroid) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(min_points_per_centroid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_points_per_centroid) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(max_points_per_centroid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seed) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(seed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decode_block_size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(decode_block_size)
        )
    );
}
extern "C" {
    #[doc = " Sets the ClusteringParameters object with reasonable defaults"]
    pub fn faiss_ClusteringParameters_init(params: *mut FaissClusteringParameters);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissClustering_H {
    _unused: [u8; 0],
}
pub type FaissClustering = FaissClustering_H;
extern "C" {
    pub fn faiss_Clustering_niter(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_nredo(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_verbose(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_spherical(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_int_centroids(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_update_index(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_frozen_centroids(arg1: *const FaissClustering)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_min_points_per_centroid(
        arg1: *const FaissClustering,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_max_points_per_centroid(
        arg1: *const FaissClustering,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_seed(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_decode_block_size(arg1: *const FaissClustering) -> usize;
}
extern "C" {
    pub fn faiss_Clustering_d(arg1: *const FaissClustering) -> usize;
}
extern "C" {
    pub fn faiss_Clustering_k(arg1: *const FaissClustering) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissClusteringIterationStats_H {
    _unused: [u8; 0],
}
pub type FaissClusteringIterationStats = FaissClusteringIterationStats_H;
extern "C" {
    pub fn faiss_ClusteringIterationStats_obj(arg1: *const FaissClusteringIterationStats) -> f32;
}
extern "C" {
    pub fn faiss_ClusteringIterationStats_time(arg1: *const FaissClusteringIterationStats) -> f64;
}
extern "C" {
    pub fn faiss_ClusteringIterationStats_time_search(
        arg1: *const FaissClusteringIterationStats,
    ) -> f64;
}
extern "C" {
    pub fn faiss_ClusteringIterationStats_imbalance_factor(
        arg1: *const FaissClusteringIterationStats,
    ) -> f64;
}
extern "C" {
    pub fn faiss_ClusteringIterationStats_nsplit(
        arg1: *const FaissClusteringIterationStats,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " getter for centroids (size = k * d)"]
    pub fn faiss_Clustering_centroids(
        clustering: *mut FaissClustering,
        centroids: *mut *mut f32,
        size: *mut usize,
    );
}
extern "C" {
    #[doc = " getter for iteration stats"]
    pub fn faiss_Clustering_iteration_stats(
        clustering: *mut FaissClustering,
        iteration_stats: *mut *mut FaissClusteringIterationStats,
        size: *mut usize,
    );
}
extern "C" {
    #[doc = " the only mandatory parameters are k and d"]
    pub fn faiss_Clustering_new(
        p_clustering: *mut *mut FaissClustering,
        d: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_new_with_params(
        p_clustering: *mut *mut FaissClustering,
        d: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        cp: *const FaissClusteringParameters,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_train(
        clustering: *mut FaissClustering,
        n: idx_t,
        x: *const f32,
        index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_free(clustering: *mut FaissClustering);
}
extern "C" {
    #[doc = " simplified interface\n\n @param d dimension of the data\n @param n nb of training vectors\n @param k nb of output centroids\n @param x training set (size n * d)\n @param centroids output centroids (size k * d)\n @param q_error final quantization error\n @return error code"]
    pub fn faiss_kmeans_clustering(
        d: usize,
        n: usize,
        k: usize,
        x: *const f32,
        centroids: *mut f32,
        q_error: *mut f32,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIndexBinary_H {
    _unused: [u8; 0],
}
pub type FaissIndexBinary = FaissIndexBinary_H;
extern "C" {
    pub fn faiss_IndexBinary_free(obj: *mut FaissIndexBinary);
}
extern "C" {
    pub fn faiss_IndexBinary_d(arg1: *const FaissIndexBinary) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexBinary_is_trained(arg1: *const FaissIndexBinary) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexBinary_ntotal(arg1: *const FaissIndexBinary) -> idx_t;
}
extern "C" {
    pub fn faiss_IndexBinary_metric_type(arg1: *const FaissIndexBinary) -> FaissMetricType;
}
extern "C" {
    pub fn faiss_IndexBinary_verbose(arg1: *const FaissIndexBinary) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexBinary_set_verbose(arg1: *mut FaissIndexBinary, arg2: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Perform training on a representative set of vectors\n\n @param index  opaque pointer to index object\n @param n      nb of training vectors\n @param x      training vectors, size n * d"]
    pub fn faiss_IndexBinary_train(
        index: *mut FaissIndexBinary,
        n: idx_t,
        x: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add n vectors of dimension d to the index.\n\n Vectors are implicitly assigned labels ntotal .. ntotal + n - 1\n This function slices the input vectors in chunks smaller than\n blocksize_add and calls add_core.\n @param index  opaque pointer to index object\n @param x      input matrix, size n * d"]
    pub fn faiss_IndexBinary_add(
        index: *mut FaissIndexBinary,
        n: idx_t,
        x: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Same as add, but stores xids instead of sequential ids.\n\n The default implementation fails with an assertion, as it is\n not supported by all indexes.\n\n @param index  opaque pointer to index object\n @param xids   if non-null, ids to store for the vectors (size n)"]
    pub fn faiss_IndexBinary_add_with_ids(
        index: *mut FaissIndexBinary,
        n: idx_t,
        x: *const u8,
        xids: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " query n vectors of dimension d to the index.\n\n return at most k vectors. If there are not enough results for a\n query, the result array is padded with -1s.\n\n @param index       opaque pointer to index object\n @param x           input vectors to search, size n * d\n @param labels      output labels of the NNs, size n*k\n @param distances   output pairwise distances, size n*k"]
    pub fn faiss_IndexBinary_search(
        index: *const FaissIndexBinary,
        n: idx_t,
        x: *const u8,
        k: idx_t,
        distances: *mut i32,
        labels: *mut idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " query n vectors of dimension d to the index.\n\n return all vectors with distance < radius. Note that many\n indexes do not implement the range_search (only the k-NN search\n is mandatory).\n\n @param index       opaque pointer to index object\n @param x           input vectors to search, size n * d\n @param radius      search radius\n @param result      result table"]
    pub fn faiss_IndexBinary_range_search(
        index: *const FaissIndexBinary,
        n: idx_t,
        x: *const u8,
        radius: ::std::os::raw::c_int,
        result: *mut FaissRangeSearchResult,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " return the indexes of the k vectors closest to the query x.\n\n This function is identical as search but only return labels of neighbors.\n @param index       opaque pointer to index object\n @param x           input vectors to search, size n * d\n @param labels      output labels of the NNs, size n*k"]
    pub fn faiss_IndexBinary_assign(
        index: *mut FaissIndexBinary,
        n: idx_t,
        x: *const u8,
        labels: *mut idx_t,
        k: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " removes all elements from the database.\n @param index       opaque pointer to index object"]
    pub fn faiss_IndexBinary_reset(index: *mut FaissIndexBinary) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " removes IDs from the index. Not supported by all indexes\n @param index       opaque pointer to index object\n @param nremove     output for the number of IDs removed"]
    pub fn faiss_IndexBinary_remove_ids(
        index: *mut FaissIndexBinary,
        sel: *const FaissIDSelector,
        n_removed: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reconstruct a stored vector (or an approximation if lossy coding)\n\n this function may not be defined for some indexes\n @param index       opaque pointer to index object\n @param key         id of the vector to reconstruct\n @param recons      reconstructed vector (size d)"]
    pub fn faiss_IndexBinary_reconstruct(
        index: *const FaissIndexBinary,
        key: idx_t,
        recons: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reconstruct vectors i0 to i0 + ni - 1\n\n this function may not be defined for some indexes\n @param index       opaque pointer to index object\n @param recons      reconstructed vector (size ni * d)"]
    pub fn faiss_IndexBinary_reconstruct_n(
        index: *const FaissIndexBinary,
        i0: idx_t,
        ni: idx_t,
        recons: *mut u8,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexFlat = FaissIndex_H;
extern "C" {
    #[doc = " Opaque type for IndexFlat"]
    pub fn faiss_IndexFlat_new(p_index: *mut *mut FaissIndexFlat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexFlat_new_with(
        p_index: *mut *mut FaissIndexFlat,
        d: idx_t,
        metric: FaissMetricType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get a pointer to the index's internal data (the `xb` field). The outputs\n become invalid after any data addition or removal operation.\n\n @param index   opaque pointer to index object\n @param p_xb    output, the pointer to the beginning of `xb`.\n @param p_size  output, the current size of `sb` in number of float values."]
    pub fn faiss_IndexFlat_xb(index: *mut FaissIndexFlat, p_xb: *mut *mut f32, p_size: *mut usize);
}
extern "C" {
    pub fn faiss_IndexFlat_cast(arg1: *mut FaissIndex) -> *mut FaissIndexFlat;
}
extern "C" {
    pub fn faiss_IndexFlat_free(obj: *mut FaissIndexFlat);
}
extern "C" {
    #[doc = " compute distance with a subset of vectors\n\n @param index   opaque pointer to index object\n @param x       query vectors, size n * d\n @param labels  indices of the vectors that should be compared\n                for each query vector, size n * k\n @param distances\n                corresponding output distances, size n * k"]
    pub fn faiss_IndexFlat_compute_distance_subset(
        index: *mut FaissIndex,
        n: idx_t,
        x: *const f32,
        k: idx_t,
        distances: *mut f32,
        labels: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexFlatIP = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexFlatIP_cast(arg1: *mut FaissIndex) -> *mut FaissIndexFlatIP;
}
extern "C" {
    pub fn faiss_IndexFlatIP_free(obj: *mut FaissIndexFlatIP);
}
extern "C" {
    #[doc = " Opaque type for IndexFlatIP"]
    pub fn faiss_IndexFlatIP_new(p_index: *mut *mut FaissIndexFlatIP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexFlatIP_new_with(
        p_index: *mut *mut FaissIndexFlatIP,
        d: idx_t,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexFlatL2 = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexFlatL2_cast(arg1: *mut FaissIndex) -> *mut FaissIndexFlatL2;
}
extern "C" {
    pub fn faiss_IndexFlatL2_free(obj: *mut FaissIndexFlatL2);
}
extern "C" {
    #[doc = " Opaque type for IndexFlatL2"]
    pub fn faiss_IndexFlatL2_new(p_index: *mut *mut FaissIndexFlatL2) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexFlatL2_new_with(
        p_index: *mut *mut FaissIndexFlatL2,
        d: idx_t,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexRefineFlat = FaissIndex_H;
extern "C" {
    #[doc = " Opaque type for IndexRefineFlat\n\n Index that queries in a base_index (a fast one) and refines the\n results with an exact search, hopefully improving the results."]
    pub fn faiss_IndexRefineFlat_new(
        p_index: *mut *mut FaissIndexRefineFlat,
        base_index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexRefineFlat_free(obj: *mut FaissIndexRefineFlat);
}
extern "C" {
    pub fn faiss_IndexRefineFlat_cast(arg1: *mut FaissIndex) -> *mut FaissIndexRefineFlat;
}
extern "C" {
    pub fn faiss_IndexRefineFlat_own_fields(
        arg1: *const FaissIndexRefineFlat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexRefineFlat_set_own_fields(
        arg1: *mut FaissIndexRefineFlat,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn faiss_IndexRefineFlat_k_factor(arg1: *const FaissIndexRefineFlat) -> f32;
}
extern "C" {
    pub fn faiss_IndexRefineFlat_set_k_factor(arg1: *mut FaissIndexRefineFlat, arg2: f32);
}
pub type FaissIndexFlat1D = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexFlat1D_cast(arg1: *mut FaissIndex) -> *mut FaissIndexFlat1D;
}
extern "C" {
    pub fn faiss_IndexFlat1D_free(obj: *mut FaissIndexFlat1D);
}
extern "C" {
    #[doc = " Opaque type for IndexFlat1D\n\n optimized version for 1D \"vectors\""]
    pub fn faiss_IndexFlat1D_new(p_index: *mut *mut FaissIndexFlat1D) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexFlat1D_new_with(
        p_index: *mut *mut FaissIndexFlat1D,
        continuous_update: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexFlat1D_update_permutation(
        index: *mut FaissIndexFlat1D,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexIVFFlat = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexIVFFlat_free(obj: *mut FaissIndexIVFFlat);
}
extern "C" {
    pub fn faiss_IndexIVFFlat_cast(arg1: *mut FaissIndex) -> *mut FaissIndexIVFFlat;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_nlist(arg1: *const FaissIndexIVFFlat) -> usize;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_nprobe(arg1: *const FaissIndexIVFFlat) -> usize;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_set_nprobe(arg1: *mut FaissIndexIVFFlat, arg2: usize);
}
extern "C" {
    pub fn faiss_IndexIVFFlat_quantizer(arg1: *const FaissIndexIVFFlat) -> *mut FaissIndex;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_quantizer_trains_alone(
        arg1: *const FaissIndexIVFFlat,
    ) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_own_fields(arg1: *const FaissIndexIVFFlat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_set_own_fields(
        arg1: *mut FaissIndexIVFFlat,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " whether object owns the quantizer"]
    pub fn faiss_IndexIVFFlat_new(p_index: *mut *mut FaissIndexIVFFlat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_new_with(
        p_index: *mut *mut FaissIndexIVFFlat,
        quantizer: *mut FaissIndex,
        d: usize,
        nlist: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_new_with_metric(
        p_index: *mut *mut FaissIndexIVFFlat,
        quantizer: *mut FaissIndex,
        d: usize,
        nlist: usize,
        metric: FaissMetricType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_add_core(
        index: *mut FaissIndexIVFFlat,
        n: idx_t,
        x: *const f32,
        xids: *const idx_t,
        precomputed_idx: *const i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Update a subset of vectors.\n\n The index must have a direct_map\n\n @param nv     nb of vectors to update\n @param idx    vector indices to update, size nv\n @param v      vectors of new values, size nv*d"]
    pub fn faiss_IndexIVFFlat_update_vectors(
        index: *mut FaissIndexIVFFlat,
        nv: ::std::os::raw::c_int,
        idx: *mut idx_t,
        v: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_RangeSearchResult_nq(arg1: *const FaissRangeSearchResult) -> usize;
}
extern "C" {
    pub fn faiss_RangeSearchResult_new(
        p_rsr: *mut *mut FaissRangeSearchResult,
        nq: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_RangeSearchResult_new_with(
        p_rsr: *mut *mut FaissRangeSearchResult,
        nq: idx_t,
        alloc_lims: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " called when lims contains the nb of elements result entries\n for each query"]
    pub fn faiss_RangeSearchResult_do_allocation(
        rsr: *mut FaissRangeSearchResult,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_RangeSearchResult_free(obj: *mut FaissRangeSearchResult);
}
extern "C" {
    pub fn faiss_RangeSearchResult_buffer_size(arg1: *const FaissRangeSearchResult) -> usize;
}
extern "C" {
    #[doc = " getter for lims: size (nq + 1)"]
    pub fn faiss_RangeSearchResult_lims(rsr: *mut FaissRangeSearchResult, lims: *mut *mut usize);
}
extern "C" {
    #[doc = " getter for labels and respective distances (not sorted):\n result for query i is labels[lims[i]:lims[i+1]]"]
    pub fn faiss_RangeSearchResult_labels(
        rsr: *mut FaissRangeSearchResult,
        labels: *mut *mut idx_t,
        distances: *mut *mut f32,
    );
}
extern "C" {
    pub fn faiss_IDSelector_free(obj: *mut FaissIDSelector);
}
extern "C" {
    #[doc = " Encapsulates a set of ids to remove."]
    pub fn faiss_IDSelector_is_member(
        sel: *const FaissIDSelector,
        id: idx_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIDSelectorRange_H {
    _unused: [u8; 0],
}
pub type FaissIDSelectorRange = FaissIDSelectorRange_H;
extern "C" {
    pub fn faiss_IDSelectorRange_free(obj: *mut FaissIDSelectorRange);
}
extern "C" {
    pub fn faiss_IDSelectorRange_imin(arg1: *const FaissIDSelectorRange) -> idx_t;
}
extern "C" {
    pub fn faiss_IDSelectorRange_imax(arg1: *const FaissIDSelectorRange) -> idx_t;
}
extern "C" {
    #[doc = " remove ids between [imni, imax)"]
    pub fn faiss_IDSelectorRange_new(
        p_sel: *mut *mut FaissIDSelectorRange,
        imin: idx_t,
        imax: idx_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIDSelectorBatch_H {
    _unused: [u8; 0],
}
pub type FaissIDSelectorBatch = FaissIDSelectorBatch_H;
extern "C" {
    pub fn faiss_IDSelectorBatch_nbits(arg1: *const FaissIDSelectorBatch) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IDSelectorBatch_mask(arg1: *const FaissIDSelectorBatch) -> idx_t;
}
extern "C" {
    #[doc = " Remove ids from a set. Repetitions of ids in the indices set\n passed to the constructor does not hurt performance. The hash\n function used for the bloom filter and GCC's implementation of\n unordered_set are just the least significant bits of the id. This\n works fine for random ids or ids in sequences but will produce many\n hash collisions if lsb's are always the same"]
    pub fn faiss_IDSelectorBatch_new(
        p_sel: *mut *mut FaissIDSelectorBatch,
        n: usize,
        indices: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIDSelectorNot_H {
    _unused: [u8; 0],
}
pub type FaissIDSelectorNot = FaissIDSelectorNot_H;
extern "C" {
    pub fn faiss_IDSelectorNot_new(
        p_sel: *mut *mut FaissIDSelectorNot,
        sel: *const FaissIDSelector,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIDSelectorAnd_H {
    _unused: [u8; 0],
}
pub type FaissIDSelectorAnd = FaissIDSelectorAnd_H;
extern "C" {
    pub fn faiss_IDSelectorAnd_new(
        p_sel: *mut *mut FaissIDSelectorAnd,
        lhs_sel: *const FaissIDSelector,
        rhs_sel: *const FaissIDSelector,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIDSelectorOr_H {
    _unused: [u8; 0],
}
pub type FaissIDSelectorOr = FaissIDSelectorOr_H;
extern "C" {
    pub fn faiss_IDSelectorOr_new(
        p_sel: *mut *mut FaissIDSelectorOr,
        lhs_sel: *const FaissIDSelector,
        rhs_sel: *const FaissIDSelector,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIDSelectorXOr_H {
    _unused: [u8; 0],
}
pub type FaissIDSelectorXOr = FaissIDSelectorXOr_H;
extern "C" {
    pub fn faiss_IDSelectorXOr_new(
        p_sel: *mut *mut FaissIDSelectorXOr,
        lhs_sel: *const FaissIDSelector,
        rhs_sel: *const FaissIDSelector,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissBufferList_H {
    _unused: [u8; 0],
}
pub type FaissBufferList = FaissBufferList_H;
extern "C" {
    pub fn faiss_BufferList_free(obj: *mut FaissBufferList);
}
extern "C" {
    pub fn faiss_BufferList_buffer_size(arg1: *const FaissBufferList) -> usize;
}
extern "C" {
    pub fn faiss_BufferList_wp(arg1: *const FaissBufferList) -> usize;
}
#[doc = " List of temporary buffers used to store results before they are\n  copied to the RangeSearchResult object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissBuffer {
    pub ids: *mut idx_t,
    pub dis: *mut f32,
}
#[test]
fn bindgen_test_layout_FaissBuffer() {
    const UNINIT: ::std::mem::MaybeUninit<FaissBuffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FaissBuffer>(),
        16usize,
        concat!("Size of: ", stringify!(FaissBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<FaissBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(FaissBuffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ids) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissBuffer),
            "::",
            stringify!(ids)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dis) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissBuffer),
            "::",
            stringify!(dis)
        )
    );
}
extern "C" {
    pub fn faiss_BufferList_append_buffer(bl: *mut FaissBufferList) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_BufferList_new(
        p_bl: *mut *mut FaissBufferList,
        buffer_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_BufferList_add(
        bl: *mut FaissBufferList,
        id: idx_t,
        dis: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " copy elemnts ofs:ofs+n-1 seen as linear data in the buffers to\n tables dest_ids, dest_dis"]
    pub fn faiss_BufferList_copy_range(
        bl: *mut FaissBufferList,
        ofs: usize,
        n: usize,
        dest_ids: *mut idx_t,
        dest_dis: *mut f32,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissRangeSearchPartialResult_H {
    _unused: [u8; 0],
}
pub type FaissRangeSearchPartialResult = FaissRangeSearchPartialResult_H;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissRangeQueryResult_H {
    _unused: [u8; 0],
}
pub type FaissRangeQueryResult = FaissRangeQueryResult_H;
extern "C" {
    pub fn faiss_RangeQueryResult_qno(arg1: *const FaissRangeQueryResult) -> idx_t;
}
extern "C" {
    pub fn faiss_RangeQueryResult_nres(arg1: *const FaissRangeQueryResult) -> usize;
}
extern "C" {
    pub fn faiss_RangeQueryResult_pres(
        arg1: *const FaissRangeQueryResult,
    ) -> *mut FaissRangeSearchPartialResult;
}
extern "C" {
    #[doc = " result structure for a single query"]
    pub fn faiss_RangeQueryResult_add(
        qr: *mut FaissRangeQueryResult,
        dis: f32,
        id: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_RangeSearchPartialResult_res(
        arg1: *const FaissRangeSearchPartialResult,
    ) -> *mut FaissRangeSearchResult;
}
extern "C" {
    pub fn faiss_RangeSearchPartialResult_new(
        p_res: *mut *mut FaissRangeSearchPartialResult,
        res_in: *mut FaissRangeSearchResult,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_RangeSearchPartialResult_finalize(
        res: *mut FaissRangeSearchPartialResult,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " called by range_search before do_allocation"]
    pub fn faiss_RangeSearchPartialResult_set_lims(
        res: *mut FaissRangeSearchPartialResult,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_RangeSearchPartialResult_new_result(
        res: *mut FaissRangeSearchPartialResult,
        qno: idx_t,
        qr: *mut *mut FaissRangeQueryResult,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissDistanceComputer_H {
    _unused: [u8; 0],
}
pub type FaissDistanceComputer = FaissDistanceComputer_H;
extern "C" {
    #[doc = " called before computing distances"]
    pub fn faiss_DistanceComputer_set_query(
        dc: *mut FaissDistanceComputer,
        x: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compute distance of vector i to current query.\n This function corresponds to the function call operator:\n DistanceComputer::operator()"]
    pub fn faiss_DistanceComputer_vector_to_query_dis(
        dc: *mut FaissDistanceComputer,
        i: idx_t,
        qd: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " compute distance between two stored vectors"]
    pub fn faiss_DistanceComputer_symmetric_dis(
        dc: *mut FaissDistanceComputer,
        i: idx_t,
        j: idx_t,
        vd: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_DistanceComputer_free(obj: *mut FaissDistanceComputer);
}
pub type FaissSearchParametersIVF = FaissSearchParameters_H;
extern "C" {
    pub fn faiss_SearchParametersIVF_free(obj: *mut FaissSearchParametersIVF);
}
extern "C" {
    pub fn faiss_SearchParametersIVF_cast(
        arg1: *mut FaissSearchParameters,
    ) -> *mut FaissSearchParametersIVF;
}
extern "C" {
    pub fn faiss_SearchParametersIVF_new(
        p_sp: *mut *mut FaissSearchParametersIVF,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_SearchParametersIVF_new_with(
        p_sp: *mut *mut FaissSearchParametersIVF,
        sel: *mut FaissIDSelector,
        nprobe: usize,
        max_codes: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_SearchParametersIVF_sel(
        arg1: *const FaissSearchParametersIVF,
    ) -> *const FaissIDSelector;
}
extern "C" {
    pub fn faiss_SearchParametersIVF_nprobe(arg1: *const FaissSearchParametersIVF) -> usize;
}
extern "C" {
    pub fn faiss_SearchParametersIVF_set_nprobe(arg1: *mut FaissSearchParametersIVF, arg2: usize);
}
extern "C" {
    pub fn faiss_SearchParametersIVF_max_codes(arg1: *const FaissSearchParametersIVF) -> usize;
}
extern "C" {
    pub fn faiss_SearchParametersIVF_set_max_codes(
        arg1: *mut FaissSearchParametersIVF,
        arg2: usize,
    );
}
pub type FaissIndexIVF = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexIVF_free(obj: *mut FaissIndexIVF);
}
extern "C" {
    pub fn faiss_IndexIVF_cast(arg1: *mut FaissIndex) -> *mut FaissIndexIVF;
}
extern "C" {
    pub fn faiss_IndexIVF_nlist(arg1: *const FaissIndexIVF) -> usize;
}
extern "C" {
    pub fn faiss_IndexIVF_nprobe(arg1: *const FaissIndexIVF) -> usize;
}
extern "C" {
    pub fn faiss_IndexIVF_set_nprobe(arg1: *mut FaissIndexIVF, arg2: usize);
}
extern "C" {
    pub fn faiss_IndexIVF_quantizer(arg1: *const FaissIndexIVF) -> *mut FaissIndex;
}
extern "C" {
    pub fn faiss_IndexIVF_quantizer_trains_alone(
        arg1: *const FaissIndexIVF,
    ) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn faiss_IndexIVF_own_fields(arg1: *const FaissIndexIVF) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVF_set_own_fields(arg1: *mut FaissIndexIVF, arg2: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " moves the entries from another dataset to self. On output,\n other is empty. add_id is added to all moved ids (for\n sequential ids, this would be this->ntotal"]
    pub fn faiss_IndexIVF_merge_from(
        index: *mut FaissIndexIVF,
        other: *mut FaissIndexIVF,
        add_id: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " copy a subset of the entries index to the other index\n\n if subset_type == 0: copies ids in [a1, a2)\n if subset_type == 1: copies ids if id % a1 == a2\n if subset_type == 2: copies inverted lists such that a1\n                      elements are left before and a2 elements are after"]
    pub fn faiss_IndexIVF_copy_subset_to(
        index: *const FaissIndexIVF,
        other: *mut FaissIndexIVF,
        subset_type: ::std::os::raw::c_int,
        a1: idx_t,
        a2: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " search a set of vectors, that are pre-quantized by the IVF\n  quantizer. Fill in the corresponding heaps with the query\n  results. search() calls this.\n\n @param n      nb of vectors to query\n @param x      query vectors, size nx * d\n @param assign coarse quantization indices, size nx * nprobe\n @param centroid_dis\n               distances to coarse centroids, size nx * nprobe\n @param distance\n               output distances, size n * k\n @param labels output labels, size n * k\n @param store_pairs store inv list index + inv list offset\n                     instead in upper/lower 32 bit of result,\n                     instead of ids (used for reranking)."]
    pub fn faiss_IndexIVF_search_preassigned(
        index: *const FaissIndexIVF,
        n: idx_t,
        x: *const f32,
        k: idx_t,
        assign: *const idx_t,
        centroid_dis: *const f32,
        distances: *mut f32,
        labels: *mut idx_t,
        store_pairs: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVF_get_list_size(index: *const FaissIndexIVF, list_no: usize) -> usize;
}
extern "C" {
    #[doc = " initialize a direct map\n\n @param new_maintain_direct_map    if true, create a direct map,\n                                   else clear it"]
    pub fn faiss_IndexIVF_make_direct_map(
        index: *mut FaissIndexIVF,
        new_maintain_direct_map: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check the inverted lists' imbalance factor.\n\n 1= perfectly balanced, >1: imbalanced"]
    pub fn faiss_IndexIVF_imbalance_factor(index: *const FaissIndexIVF) -> f64;
}
extern "C" {
    #[doc = " display some stats about the inverted lists of the index"]
    pub fn faiss_IndexIVF_print_stats(index: *const FaissIndexIVF);
}
extern "C" {
    #[doc = " Get the IDs in an inverted list. IDs are written to `invlist`, which must be\n large enough\n to accommodate the full list.\n\n @param list_no the list ID\n @param invlist output pointer to a slice of memory, at least as long as the\n list's size\n @see faiss_IndexIVF_get_list_size(size_t)"]
    pub fn faiss_IndexIVF_invlists_get_ids(
        index: *const FaissIndexIVF,
        list_no: usize,
        invlist: *mut idx_t,
    );
}
extern "C" {
    pub fn faiss_IndexIVF_train_encoder(
        index: *mut FaissIndexIVF,
        n: idx_t,
        x: *const f32,
        assign: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIndexIVFStats {
    pub nq: usize,
    pub nlist: usize,
    pub ndis: usize,
    pub nheap_updates: usize,
    pub quantization_time: f64,
    pub search_time: f64,
}
#[test]
fn bindgen_test_layout_FaissIndexIVFStats() {
    const UNINIT: ::std::mem::MaybeUninit<FaissIndexIVFStats> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FaissIndexIVFStats>(),
        48usize,
        concat!("Size of: ", stringify!(FaissIndexIVFStats))
    );
    assert_eq!(
        ::std::mem::align_of::<FaissIndexIVFStats>(),
        8usize,
        concat!("Alignment of ", stringify!(FaissIndexIVFStats))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissIndexIVFStats),
            "::",
            stringify!(nq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nlist) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissIndexIVFStats),
            "::",
            stringify!(nlist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ndis) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissIndexIVFStats),
            "::",
            stringify!(ndis)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nheap_updates) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissIndexIVFStats),
            "::",
            stringify!(nheap_updates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quantization_time) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissIndexIVFStats),
            "::",
            stringify!(quantization_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).search_time) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissIndexIVFStats),
            "::",
            stringify!(search_time)
        )
    );
}
extern "C" {
    pub fn faiss_IndexIVFStats_reset(stats: *mut FaissIndexIVFStats);
}
extern "C" {
    #[doc = " global var that collects all statists"]
    pub fn faiss_get_indexIVF_stats() -> *mut FaissIndexIVFStats;
}
pub type FaissIndexLSH = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexLSH_free(obj: *mut FaissIndexLSH);
}
extern "C" {
    pub fn faiss_IndexLSH_cast(arg1: *mut FaissIndex) -> *mut FaissIndexLSH;
}
extern "C" {
    pub fn faiss_IndexLSH_nbits(arg1: *const FaissIndexLSH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexLSH_code_size(arg1: *const FaissIndexLSH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexLSH_rotate_data(arg1: *const FaissIndexLSH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexLSH_train_thresholds(arg1: *const FaissIndexLSH) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The sign of each vector component is put in a binary signature"]
    pub fn faiss_IndexLSH_new(
        p_index: *mut *mut FaissIndexLSH,
        d: idx_t,
        nbits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexLSH_new_with_options(
        p_index: *mut *mut FaissIndexLSH,
        d: idx_t,
        nbits: ::std::os::raw::c_int,
        rotate_data: ::std::os::raw::c_int,
        train_thresholds: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissVectorTransform_H {
    _unused: [u8; 0],
}
pub type FaissVectorTransform = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_VectorTransform_free(obj: *mut FaissVectorTransform);
}
extern "C" {
    pub fn faiss_VectorTransform_is_trained(
        arg1: *const FaissVectorTransform,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_VectorTransform_d_in(arg1: *const FaissVectorTransform) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_VectorTransform_d_out(arg1: *const FaissVectorTransform) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Perform training on a representative set of vectors\n\n @param vt     opaque pointer to VectorTransform object\n @param n      nb of training vectors\n @param x      training vectors, size n * d"]
    pub fn faiss_VectorTransform_train(
        vt: *mut FaissVectorTransform,
        n: idx_t,
        x: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " apply the random rotation, return new allocated matrix\n @param     x size n * d_in\n @return    size n * d_out"]
    pub fn faiss_VectorTransform_apply(
        vt: *const FaissVectorTransform,
        n: idx_t,
        x: *const f32,
    ) -> *mut f32;
}
extern "C" {
    #[doc = " apply transformation and result is pre-allocated\n @param     x size n * d_in\n @param     xt size n * d_out"]
    pub fn faiss_VectorTransform_apply_noalloc(
        vt: *const FaissVectorTransform,
        n: idx_t,
        x: *const f32,
        xt: *mut f32,
    );
}
extern "C" {
    #[doc = " reverse transformation. May not be implemented or may return\n approximate result"]
    pub fn faiss_VectorTransform_reverse_transform(
        vt: *const FaissVectorTransform,
        n: idx_t,
        xt: *const f32,
        x: *mut f32,
    );
}
pub type FaissLinearTransform = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_LinearTransform_free(obj: *mut FaissLinearTransform);
}
extern "C" {
    #[doc = " compute x = A^T * (x - b)\n is reverse transform if A has orthonormal lines"]
    pub fn faiss_LinearTransform_transform_transpose(
        vt: *const FaissLinearTransform,
        n: idx_t,
        y: *const f32,
        x: *mut f32,
    );
}
extern "C" {
    #[doc = " compute A^T * A to set the is_orthonormal flag"]
    pub fn faiss_LinearTransform_set_is_orthonormal(vt: *mut FaissLinearTransform);
}
extern "C" {
    pub fn faiss_LinearTransform_have_bias(
        arg1: *const FaissLinearTransform,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_LinearTransform_is_orthonormal(
        arg1: *const FaissLinearTransform,
    ) -> ::std::os::raw::c_int;
}
pub type FaissRandomRotationMatrix = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_RandomRotationMatrix_free(obj: *mut FaissRandomRotationMatrix);
}
extern "C" {
    #[doc = " Getter for is_orthonormal"]
    pub fn faiss_RandomRotationMatrix_new_with(
        p_vt: *mut *mut FaissRandomRotationMatrix,
        d_in: ::std::os::raw::c_int,
        d_out: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type FaissPCAMatrix = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_PCAMatrix_free(obj: *mut FaissPCAMatrix);
}
extern "C" {
    pub fn faiss_PCAMatrix_new_with(
        p_vt: *mut *mut FaissPCAMatrix,
        d_in: ::std::os::raw::c_int,
        d_out: ::std::os::raw::c_int,
        eigen_power: f32,
        random_rotation: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_PCAMatrix_eigen_power(arg1: *const FaissPCAMatrix) -> f32;
}
extern "C" {
    pub fn faiss_PCAMatrix_random_rotation(arg1: *const FaissPCAMatrix) -> ::std::os::raw::c_int;
}
pub type FaissITQMatrix = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_ITQMatrix_free(obj: *mut FaissITQMatrix);
}
extern "C" {
    #[doc = " Getter for random_rotation"]
    pub fn faiss_ITQMatrix_new_with(
        p_vt: *mut *mut FaissITQMatrix,
        d: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type FaissITQTransform = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_ITQTransform_free(obj: *mut FaissITQTransform);
}
extern "C" {
    pub fn faiss_ITQTransform_new_with(
        p_vt: *mut *mut FaissITQTransform,
        d_in: ::std::os::raw::c_int,
        d_out: ::std::os::raw::c_int,
        do_pca: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_ITQTransform_do_pca(arg1: *const FaissITQTransform) -> ::std::os::raw::c_int;
}
pub type FaissOPQMatrix = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_OPQMatrix_free(obj: *mut FaissOPQMatrix);
}
extern "C" {
    #[doc = " Getter for do_pca"]
    pub fn faiss_OPQMatrix_new_with(
        p_vt: *mut *mut FaissOPQMatrix,
        d: ::std::os::raw::c_int,
        M: ::std::os::raw::c_int,
        d2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_OPQMatrix_verbose(arg1: *const FaissOPQMatrix) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_OPQMatrix_set_verbose(arg1: *mut FaissOPQMatrix, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn faiss_OPQMatrix_niter(arg1: *const FaissOPQMatrix) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_OPQMatrix_set_niter(arg1: *mut FaissOPQMatrix, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn faiss_OPQMatrix_niter_pq(arg1: *const FaissOPQMatrix) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_OPQMatrix_set_niter_pq(arg1: *mut FaissOPQMatrix, arg2: ::std::os::raw::c_int);
}
pub type FaissRemapDimensionsTransform = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_RemapDimensionsTransform_free(obj: *mut FaissRemapDimensionsTransform);
}
extern "C" {
    pub fn faiss_RemapDimensionsTransform_new_with(
        p_vt: *mut *mut FaissRemapDimensionsTransform,
        d_in: ::std::os::raw::c_int,
        d_out: ::std::os::raw::c_int,
        uniform: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type FaissNormalizationTransform = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_NormalizationTransform_free(obj: *mut FaissNormalizationTransform);
}
extern "C" {
    pub fn faiss_NormalizationTransform_new_with(
        p_vt: *mut *mut FaissNormalizationTransform,
        d: ::std::os::raw::c_int,
        norm: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_NormalizationTransform_norm(arg1: *const FaissNormalizationTransform) -> f32;
}
pub type FaissCenteringTransform = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_CenteringTransform_free(obj: *mut FaissCenteringTransform);
}
extern "C" {
    pub fn faiss_CenteringTransform_new_with(
        p_vt: *mut *mut FaissCenteringTransform,
        d: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexPreTransform = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexPreTransform_free(obj: *mut FaissIndexPreTransform);
}
extern "C" {
    pub fn faiss_IndexPreTransform_cast(arg1: *mut FaissIndex) -> *mut FaissIndexPreTransform;
}
extern "C" {
    pub fn faiss_IndexPreTransform_index(arg1: *const FaissIndexPreTransform) -> *mut FaissIndex;
}
extern "C" {
    pub fn faiss_IndexPreTransform_own_fields(
        arg1: *const FaissIndexPreTransform,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexPreTransform_set_own_fields(
        arg1: *mut FaissIndexPreTransform,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Index that applies a LinearTransform transform on vectors before\n  handing them over to a sub-index"]
    pub fn faiss_IndexPreTransform_new(
        p_index: *mut *mut FaissIndexPreTransform,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexPreTransform_new_with(
        p_index: *mut *mut FaissIndexPreTransform,
        index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexPreTransform_new_with_transform(
        p_index: *mut *mut FaissIndexPreTransform,
        ltrans: *mut FaissVectorTransform,
        index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexPreTransform_prepend_transform(
        index: *mut FaissIndexPreTransform,
        ltrans: *mut FaissVectorTransform,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexReplicas = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexReplicas_free(obj: *mut FaissIndexReplicas);
}
extern "C" {
    pub fn faiss_IndexReplicas_own_fields(arg1: *const FaissIndexReplicas)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexReplicas_set_own_fields(
        arg1: *mut FaissIndexReplicas,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Index that concatenates the results from several sub-indexes"]
    pub fn faiss_IndexReplicas_new(
        p_index: *mut *mut FaissIndexReplicas,
        d: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexReplicas_new_with_options(
        p_index: *mut *mut FaissIndexReplicas,
        d: idx_t,
        threaded: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexReplicas_add_replica(
        index: *mut FaissIndexReplicas,
        replica: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexReplicas_remove_replica(
        index: *mut FaissIndexReplicas,
        replica: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexReplicas_at(
        index: *mut FaissIndexReplicas,
        i: ::std::os::raw::c_int,
    ) -> *mut FaissIndex;
}
#[doc = "< 8 bits per component"]
pub const FaissQuantizerType_QT_8bit: FaissQuantizerType = 0;
#[doc = "< 4 bits per component"]
pub const FaissQuantizerType_QT_4bit: FaissQuantizerType = 1;
#[doc = "< same, shared range for all dimensions"]
pub const FaissQuantizerType_QT_8bit_uniform: FaissQuantizerType = 2;
pub const FaissQuantizerType_QT_4bit_uniform: FaissQuantizerType = 3;
pub const FaissQuantizerType_QT_fp16: FaissQuantizerType = 4;
#[doc = "< fast indexing of uint8s"]
pub const FaissQuantizerType_QT_8bit_direct: FaissQuantizerType = 5;
#[doc = "< 6 bits per component"]
pub const FaissQuantizerType_QT_6bit: FaissQuantizerType = 6;
pub type FaissQuantizerType = ::std::os::raw::c_uint;
pub type FaissIndexScalarQuantizer = FaissIndex_H;
extern "C" {
    #[doc = " Opaque type for IndexScalarQuantizer"]
    pub fn faiss_IndexScalarQuantizer_new(
        p_index: *mut *mut FaissIndexScalarQuantizer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexScalarQuantizer_new_with(
        p_index: *mut *mut FaissIndexScalarQuantizer,
        d: idx_t,
        qt: FaissQuantizerType,
        metric: FaissMetricType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexScalarQuantizer_cast(arg1: *mut FaissIndex)
        -> *mut FaissIndexScalarQuantizer;
}
extern "C" {
    pub fn faiss_IndexScalarQuantizer_free(obj: *mut FaissIndexScalarQuantizer);
}
pub type FaissIndexIVFScalarQuantizer = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_cast(
        arg1: *mut FaissIndex,
    ) -> *mut FaissIndexIVFScalarQuantizer;
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_free(obj: *mut FaissIndexIVFScalarQuantizer);
}
extern "C" {
    #[doc = " Opaque type for IndexIVFScalarQuantizer"]
    pub fn faiss_IndexIVFScalarQuantizer_new(
        p_index: *mut *mut FaissIndexIVFScalarQuantizer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_new_with(
        p_index: *mut *mut FaissIndexIVFScalarQuantizer,
        quantizer: *mut FaissIndex,
        d: idx_t,
        nlist: usize,
        qt: FaissQuantizerType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_new_with_metric(
        p_index: *mut *mut FaissIndexIVFScalarQuantizer,
        quantizer: *mut FaissIndex,
        d: usize,
        nlist: usize,
        qt: FaissQuantizerType,
        metric: FaissMetricType,
        encode_residual: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_nlist(arg1: *const FaissIndexIVFScalarQuantizer) -> usize;
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_nprobe(arg1: *const FaissIndexIVFScalarQuantizer)
        -> usize;
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_set_nprobe(
        arg1: *mut FaissIndexIVFScalarQuantizer,
        arg2: usize,
    );
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_quantizer(
        arg1: *const FaissIndexIVFScalarQuantizer,
    ) -> *mut FaissIndex;
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_own_fields(
        arg1: *const FaissIndexIVFScalarQuantizer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_set_own_fields(
        arg1: *mut FaissIndexIVFScalarQuantizer,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " whether object owns the quantizer"]
    pub fn faiss_IndexIVFScalarQuantizer_add_core(
        index: *mut FaissIndexIVFScalarQuantizer,
        n: idx_t,
        x: *const f32,
        xids: *const idx_t,
        precomputed_idx: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexShards = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexShards_free(obj: *mut FaissIndexShards);
}
extern "C" {
    pub fn faiss_IndexShards_own_fields(arg1: *const FaissIndexShards) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexShards_set_own_fields(
        arg1: *mut FaissIndexShards,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn faiss_IndexShards_successive_ids(arg1: *const FaissIndexShards)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexShards_set_successive_ids(
        arg1: *mut FaissIndexShards,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Index that concatenates the results from several sub-indexes"]
    pub fn faiss_IndexShards_new(
        p_index: *mut *mut FaissIndexShards,
        d: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexShards_new_with_options(
        p_index: *mut *mut FaissIndexShards,
        d: idx_t,
        threaded: ::std::os::raw::c_int,
        successive_ids: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexShards_add_shard(
        index: *mut FaissIndexShards,
        shard: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexShards_remove_shard(
        index: *mut FaissIndexShards,
        shard: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexShards_at(
        index: *mut FaissIndexShards,
        i: ::std::os::raw::c_int,
    ) -> *mut FaissIndex;
}
pub type FaissIndexIDMap = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexIDMap_own_fields(arg1: *const FaissIndexIDMap) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIDMap_set_own_fields(arg1: *mut FaissIndexIDMap, arg2: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Index that translates search results to ids"]
    pub fn faiss_IndexIDMap_new(
        p_index: *mut *mut FaissIndexIDMap,
        index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIDMap_cast(arg1: *mut FaissIndex) -> *mut FaissIndexIDMap;
}
extern "C" {
    #[doc = " get a pointer to the index map's internal ID vector (the `id_map` field).\n The outputs of this function become invalid after any operation that can\n modify the index.\n\n @param index   opaque pointer to index object\n @param p_id_map    output, the pointer to the beginning of `id_map`.\n @param p_size  output, the current length of `id_map`."]
    pub fn faiss_IndexIDMap_id_map(
        index: *mut FaissIndexIDMap,
        p_id_map: *mut *mut idx_t,
        p_size: *mut usize,
    );
}
extern "C" {
    #[doc = " get a pointer to the sub-index (the `index` field).\n The outputs of this function become invalid after any operation that can\n modify the index.\n\n @param index   opaque pointer to index object"]
    pub fn faiss_IndexIDMap_sub_index(index: *mut FaissIndexIDMap) -> *mut FaissIndex;
}
pub type FaissIndexIDMap2 = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexIDMap2_own_fields(arg1: *const FaissIndexIDMap2) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIDMap2_set_own_fields(
        arg1: *mut FaissIndexIDMap2,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " same as IndexIDMap but also provides an efficient reconstruction\nimplementation via a 2-way index"]
    pub fn faiss_IndexIDMap2_new(
        p_index: *mut *mut FaissIndexIDMap2,
        index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " make the rev_map from scratch"]
    pub fn faiss_IndexIDMap2_construct_rev_map(
        index: *mut FaissIndexIDMap2,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIDMap2_cast(arg1: *mut FaissIndex) -> *mut FaissIndexIDMap2;
}
extern "C" {
    #[doc = " get a pointer to the index map's internal ID vector (the `id_map` field).\n The outputs of this function become invalid after any operation that can\n modify the index.\n\n @param index   opaque pointer to index object\n @param p_id_map    output, the pointer to the beginning of `id_map`.\n @param p_size  output, the current length of `id_map`."]
    pub fn faiss_IndexIDMap2_id_map(
        index: *mut FaissIndexIDMap2,
        p_id_map: *mut *mut idx_t,
        p_size: *mut usize,
    );
}
extern "C" {
    #[doc = " get a pointer to the sub-index (the `index` field).\n The outputs of this function become invalid after any operation that can\n modify the index.\n\n @param index   opaque pointer to index object"]
    pub fn faiss_IndexIDMap2_sub_index(index: *mut FaissIndexIDMap2) -> *mut FaissIndex;
}
pub type FILE = [u64; 27usize];
extern "C" {
    #[doc = " Clone an index. This is equivalent to `faiss::clone_index`"]
    pub fn faiss_clone_index(
        arg1: *const FaissIndex,
        p_out: *mut *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Clone a binary index. This is equivalent to `faiss::clone_index_binary`"]
    pub fn faiss_clone_index_binary(
        arg1: *const FaissIndexBinary,
        p_out: *mut *mut FaissIndexBinary,
    ) -> ::std::os::raw::c_int;
}
#[doc = " No error"]
pub const FaissErrorCode_OK: FaissErrorCode = 0;
#[doc = " Any exception other than Faiss or standard C++ library exceptions"]
pub const FaissErrorCode_UNKNOWN_EXCEPT: FaissErrorCode = -1;
#[doc = " Faiss library exception"]
pub const FaissErrorCode_FAISS_EXCEPT: FaissErrorCode = -2;
#[doc = " Standard C++ library exception"]
pub const FaissErrorCode_STD_EXCEPT: FaissErrorCode = -4;
#[doc = " An error code which depends on the exception thrown from the previous\n operation. See `faiss_get_last_error` to retrieve the error message."]
pub type FaissErrorCode = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Get the error message of the last failed operation performed by Faiss.\n The given pointer is only invalid until another Faiss function is\n called."]
    pub fn faiss_get_last_error() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Build an index with the sequence of processing steps described in\n  the string."]
    pub fn faiss_index_factory(
        p_index: *mut *mut FaissIndex,
        d: ::std::os::raw::c_int,
        description: *const ::std::os::raw::c_char,
        metric: FaissMetricType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Build a binary index with the sequence of processing steps described in\n  the string."]
    pub fn faiss_index_binary_factory(
        p_index: *mut *mut FaissIndexBinary,
        d: ::std::os::raw::c_int,
        description: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write index to a file.\n This is equivalent to `faiss::write_index` when a file descriptor is\n provided."]
    pub fn faiss_write_index(idx: *const FaissIndex, f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write index to a file.\n This is equivalent to `faiss::write_index` when a file path is provided."]
    pub fn faiss_write_index_fname(
        idx: *const FaissIndex,
        fname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read index from a file.\n This is equivalent to `faiss:read_index` when a file descriptor is given."]
    pub fn faiss_read_index(
        f: *mut FILE,
        io_flags: ::std::os::raw::c_int,
        p_out: *mut *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read index from a file.\n This is equivalent to `faiss:read_index` when a file path is given."]
    pub fn faiss_read_index_fname(
        fname: *const ::std::os::raw::c_char,
        io_flags: ::std::os::raw::c_int,
        p_out: *mut *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write index to a file.\n This is equivalent to `faiss::write_index_binary` when a file descriptor is\n provided."]
    pub fn faiss_write_index_binary(
        idx: *const FaissIndexBinary,
        f: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write index to a file.\n This is equivalent to `faiss::write_index_binary` when a file path is\n provided."]
    pub fn faiss_write_index_binary_fname(
        idx: *const FaissIndexBinary,
        fname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read index from a file.\n This is equivalent to `faiss:read_index_binary` when a file descriptor is\n given."]
    pub fn faiss_read_index_binary(
        f: *mut FILE,
        io_flags: ::std::os::raw::c_int,
        p_out: *mut *mut FaissIndexBinary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read index from a file.\n This is equivalent to `faiss:read_index_binary` when a file path is given."]
    pub fn faiss_read_index_binary_fname(
        fname: *const ::std::os::raw::c_char,
        io_flags: ::std::os::raw::c_int,
        p_out: *mut *mut FaissIndexBinary,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compute pairwise distances between sets of vectors"]
    pub fn faiss_pairwise_L2sqr(
        d: i64,
        nq: i64,
        xq: *const f32,
        nb: i64,
        xb: *const f32,
        dis: *mut f32,
        ldq: i64,
        ldb: i64,
        ldd: i64,
    );
}
extern "C" {
    #[doc = " Compute pairwise distances between sets of vectors\n arguments from \"faiss_pairwise_L2sqr\"\n ldq equal -1 by default\n ldb equal -1 by default\n ldd equal -1 by default"]
    pub fn faiss_pairwise_L2sqr_with_defaults(
        d: i64,
        nq: i64,
        xq: *const f32,
        nb: i64,
        xb: *const f32,
        dis: *mut f32,
    );
}
extern "C" {
    #[doc = " compute the inner product between nx vectors x and one y"]
    pub fn faiss_fvec_inner_products_ny(
        ip: *mut f32,
        x: *const f32,
        y: *const f32,
        d: usize,
        ny: usize,
    );
}
extern "C" {
    #[doc = " compute ny square L2 distance between x and a set of contiguous y vectors"]
    pub fn faiss_fvec_L2sqr_ny(dis: *mut f32, x: *const f32, y: *const f32, d: usize, ny: usize);
}
extern "C" {
    #[doc = " squared norm of a vector"]
    pub fn faiss_fvec_norm_L2sqr(x: *const f32, d: usize) -> f32;
}
extern "C" {
    #[doc = " compute the L2 norms for a set of vectors"]
    pub fn faiss_fvec_norms_L2(norms: *mut f32, x: *const f32, d: usize, nx: usize);
}
extern "C" {
    #[doc = " same as fvec_norms_L2, but computes squared norms"]
    pub fn faiss_fvec_norms_L2sqr(norms: *mut f32, x: *const f32, d: usize, nx: usize);
}
extern "C" {
    #[doc = " L2-renormalize a set of vector. Nothing done if the vector is 0-normed"]
    pub fn faiss_fvec_renorm_L2(d: usize, nx: usize, x: *mut f32);
}
extern "C" {
    #[doc = " Setter of threshold value on nx above which we switch to BLAS to compute\n distances"]
    pub fn faiss_set_distance_compute_blas_threshold(value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Getter of threshold value on nx above which we switch to BLAS to compute\n distances"]
    pub fn faiss_get_distance_compute_blas_threshold() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Setter of block sizes value for BLAS distance computations"]
    pub fn faiss_set_distance_compute_blas_query_bs(value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Getter of block sizes value for BLAS distance computations"]
    pub fn faiss_get_distance_compute_blas_query_bs() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Setter of block sizes value for BLAS distance computations"]
    pub fn faiss_set_distance_compute_blas_database_bs(value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Getter of block sizes value for BLAS distance computations"]
    pub fn faiss_get_distance_compute_blas_database_bs() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Setter of number of results we switch to a reservoir to collect results\n rather than a heap"]
    pub fn faiss_set_distance_compute_min_k_reservoir(value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Getter of number of results we switch to a reservoir to collect results\n rather than a heap"]
    pub fn faiss_get_distance_compute_min_k_reservoir() -> ::std::os::raw::c_int;
}
