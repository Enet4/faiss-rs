/* automatically generated by rust-bindgen 0.55.1 */

pub type __int64_t = ::std::os::raw::c_long;
pub type faiss_idx_t = i64;
pub type idx_t = faiss_idx_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissRangeSearchResult_H {
    _unused: [u8; 0],
}
pub type FaissRangeSearchResult = FaissRangeSearchResult_H;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIDSelector_H {
    _unused: [u8; 0],
}
pub type FaissIDSelector = FaissIDSelector_H;
#[doc = "< maximum inner product search"]
pub const FaissMetricType_METRIC_INNER_PRODUCT: FaissMetricType = 0;
#[doc = "< squared L2 search"]
pub const FaissMetricType_METRIC_L2: FaissMetricType = 1;
#[doc = "< L1 (aka cityblock)"]
pub const FaissMetricType_METRIC_L1: FaissMetricType = 2;
#[doc = "< infinity distance"]
pub const FaissMetricType_METRIC_Linf: FaissMetricType = 3;
#[doc = "< L_p distance, p is given by metric_arg"]
pub const FaissMetricType_METRIC_Lp: FaissMetricType = 4;
#[doc = " some additional metrics defined in scipy.spatial.distance"]
pub const FaissMetricType_METRIC_Canberra: FaissMetricType = 20;
#[doc = " some additional metrics defined in scipy.spatial.distance"]
pub const FaissMetricType_METRIC_BrayCurtis: FaissMetricType = 21;
#[doc = " some additional metrics defined in scipy.spatial.distance"]
pub const FaissMetricType_METRIC_JensenShannon: FaissMetricType = 22;
#[doc = " Some algorithms support both an inner product version and a L2 search version."]
pub type FaissMetricType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIndex_H {
    _unused: [u8; 0],
}
pub type FaissIndex = FaissIndex_H;
extern "C" {
    pub fn faiss_Index_free(obj: *mut FaissIndex);
}
extern "C" {
    pub fn faiss_Index_d(arg1: *const FaissIndex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Index_is_trained(arg1: *const FaissIndex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Index_ntotal(arg1: *const FaissIndex) -> idx_t;
}
extern "C" {
    pub fn faiss_Index_metric_type(arg1: *const FaissIndex) -> FaissMetricType;
}
extern "C" {
    #[doc = " Perform training on a representative set of vectors"]
    #[doc = ""]
    #[doc = " @param index  opaque pointer to index object"]
    #[doc = " @param n      nb of training vectors"]
    #[doc = " @param x      training vecors, size n * d"]
    pub fn faiss_Index_train(
        index: *mut FaissIndex,
        n: idx_t,
        x: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add n vectors of dimension d to the index."]
    #[doc = ""]
    #[doc = " Vectors are implicitly assigned labels ntotal .. ntotal + n - 1"]
    #[doc = " This function slices the input vectors in chuncks smaller than"]
    #[doc = " blocksize_add and calls add_core."]
    #[doc = " @param index  opaque pointer to index object"]
    #[doc = " @param x      input matrix, size n * d"]
    pub fn faiss_Index_add(
        index: *mut FaissIndex,
        n: idx_t,
        x: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Same as add, but stores xids instead of sequential ids."]
    #[doc = ""]
    #[doc = " The default implementation fails with an assertion, as it is"]
    #[doc = " not supported by all indexes."]
    #[doc = ""]
    #[doc = " @param index  opaque pointer to index object"]
    #[doc = " @param xids   if non-null, ids to store for the vectors (size n)"]
    pub fn faiss_Index_add_with_ids(
        index: *mut FaissIndex,
        n: idx_t,
        x: *const f32,
        xids: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " query n vectors of dimension d to the index."]
    #[doc = ""]
    #[doc = " return at most k vectors. If there are not enough results for a"]
    #[doc = " query, the result array is padded with -1s."]
    #[doc = ""]
    #[doc = " @param index       opaque pointer to index object"]
    #[doc = " @param x           input vectors to search, size n * d"]
    #[doc = " @param labels      output labels of the NNs, size n*k"]
    #[doc = " @param distances   output pairwise distances, size n*k"]
    pub fn faiss_Index_search(
        index: *const FaissIndex,
        n: idx_t,
        x: *const f32,
        k: idx_t,
        distances: *mut f32,
        labels: *mut idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " query n vectors of dimension d to the index."]
    #[doc = ""]
    #[doc = " return all vectors with distance < radius. Note that many"]
    #[doc = " indexes do not implement the range_search (only the k-NN search"]
    #[doc = " is mandatory)."]
    #[doc = ""]
    #[doc = " @param index       opaque pointer to index object"]
    #[doc = " @param x           input vectors to search, size n * d"]
    #[doc = " @param radius      search radius"]
    #[doc = " @param result      result table"]
    pub fn faiss_Index_range_search(
        index: *const FaissIndex,
        n: idx_t,
        x: *const f32,
        radius: f32,
        result: *mut FaissRangeSearchResult,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " return the indexes of the k vectors closest to the query x."]
    #[doc = ""]
    #[doc = " This function is identical as search but only return labels of neighbors."]
    #[doc = " @param index       opaque pointer to index object"]
    #[doc = " @param x           input vectors to search, size n * d"]
    #[doc = " @param labels      output labels of the NNs, size n*k"]
    pub fn faiss_Index_assign(
        index: *mut FaissIndex,
        n: idx_t,
        x: *const f32,
        labels: *mut idx_t,
        k: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " removes all elements from the database."]
    #[doc = " @param index       opaque pointer to index object"]
    pub fn faiss_Index_reset(index: *mut FaissIndex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " removes IDs from the index. Not supported by all indexes"]
    #[doc = " @param index       opaque pointer to index object"]
    #[doc = " @param nremove     output for the number of IDs removed"]
    pub fn faiss_Index_remove_ids(
        index: *mut FaissIndex,
        sel: *const FaissIDSelector,
        n_removed: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reconstruct a stored vector (or an approximation if lossy coding)"]
    #[doc = ""]
    #[doc = " this function may not be defined for some indexes"]
    #[doc = " @param index       opaque pointer to index object"]
    #[doc = " @param key         id of the vector to reconstruct"]
    #[doc = " @param recons      reconstucted vector (size d)"]
    pub fn faiss_Index_reconstruct(
        index: *const FaissIndex,
        key: idx_t,
        recons: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reconstruct vectors i0 to i0 + ni - 1"]
    #[doc = ""]
    #[doc = " this function may not be defined for some indexes"]
    #[doc = " @param index       opaque pointer to index object"]
    #[doc = " @param recons      reconstucted vector (size ni * d)"]
    pub fn faiss_Index_reconstruct_n(
        index: *const FaissIndex,
        i0: idx_t,
        ni: idx_t,
        recons: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Computes a residual vector after indexing encoding."]
    #[doc = ""]
    #[doc = " The residual vector is the difference between a vector and the"]
    #[doc = " reconstruction that can be decoded from its representation in"]
    #[doc = " the index. The residual can be used for multiple-stage indexing"]
    #[doc = " methods, like IndexIVF's methods."]
    #[doc = ""]
    #[doc = " @param index       opaque pointer to index object"]
    #[doc = " @param x           input vector, size d"]
    #[doc = " @param residual    output residual vector, size d"]
    #[doc = " @param key         encoded index, as returned by search and assign"]
    pub fn faiss_Index_compute_residual(
        index: *const FaissIndex,
        x: *const f32,
        residual: *mut f32,
        key: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Computes a residual vector after indexing encoding."]
    #[doc = ""]
    #[doc = " The residual vector is the difference between a vector and the"]
    #[doc = " reconstruction that can be decoded from its representation in"]
    #[doc = " the index. The residual can be used for multiple-stage indexing"]
    #[doc = " methods, like IndexIVF's methods."]
    #[doc = ""]
    #[doc = " @param index       opaque pointer to index object"]
    #[doc = " @param n           number of vectors"]
    #[doc = " @param x           input vector, size (n x d)"]
    #[doc = " @param residuals    output residual vectors, size (n x d)"]
    #[doc = " @param keys         encoded index, as returned by search and assign"]
    pub fn faiss_Index_compute_residual_n(
        index: *const FaissIndex,
        n: idx_t,
        x: *const f32,
        residuals: *mut f32,
        keys: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissParameterRange_H {
    _unused: [u8; 0],
}
pub type FaissParameterRange = FaissParameterRange_H;
extern "C" {
    pub fn faiss_ParameterRange_name(
        arg1: *const FaissParameterRange,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Getter for the values in the range. The output values are invalidated"]
    #[doc = " upon any other modification of the range."]
    pub fn faiss_ParameterRange_values(
        arg1: *mut FaissParameterRange,
        arg2: *mut *mut f64,
        arg3: *mut usize,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissParameterSpace_H {
    _unused: [u8; 0],
}
pub type FaissParameterSpace = FaissParameterSpace_H;
extern "C" {
    pub fn faiss_ParameterSpace_free(obj: *mut FaissParameterSpace);
}
extern "C" {
    #[doc = " Parameter space default constructor"]
    pub fn faiss_ParameterSpace_new(space: *mut *mut FaissParameterSpace) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " nb of combinations, = product of values sizes"]
    pub fn faiss_ParameterSpace_n_combinations(arg1: *const FaissParameterSpace) -> usize;
}
extern "C" {
    #[doc = " get string representation of the combination"]
    #[doc = " by writing it to the given character buffer."]
    #[doc = " A buffer size of 1000 ensures that the full name is collected."]
    pub fn faiss_ParameterSpace_combination_name(
        arg1: *const FaissParameterSpace,
        arg2: usize,
        arg3: *mut ::std::os::raw::c_char,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " set a combination of parameters described by a string"]
    pub fn faiss_ParameterSpace_set_index_parameters(
        arg1: *const FaissParameterSpace,
        arg2: *mut FaissIndex,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " set a combination of parameters on an index"]
    pub fn faiss_ParameterSpace_set_index_parameters_cno(
        arg1: *const FaissParameterSpace,
        arg2: *mut FaissIndex,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " set one of the parameters"]
    pub fn faiss_ParameterSpace_set_index_parameter(
        arg1: *const FaissParameterSpace,
        arg2: *mut FaissIndex,
        arg3: *const ::std::os::raw::c_char,
        arg4: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " print a description on stdout"]
    pub fn faiss_ParameterSpace_display(arg1: *const FaissParameterSpace);
}
extern "C" {
    #[doc = " add a new parameter (or return it if it exists)"]
    pub fn faiss_ParameterSpace_add_range(
        arg1: *mut FaissParameterSpace,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut FaissParameterRange,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Class for the clustering parameters. Can be passed to the"]
#[doc = " constructor of the Clustering object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissClusteringParameters {
    #[doc = "< clustering iterations"]
    pub niter: ::std::os::raw::c_int,
    #[doc = "< redo clustering this many times and keep best"]
    pub nredo: ::std::os::raw::c_int,
    #[doc = "< (bool)"]
    pub verbose: ::std::os::raw::c_int,
    #[doc = "< (bool) do we want normalized centroids?"]
    pub spherical: ::std::os::raw::c_int,
    #[doc = "< (bool) update index after each iteration?"]
    pub update_index: ::std::os::raw::c_int,
    #[doc = "< (bool) use the centroids provided as input and do not change them during iterations"]
    pub frozen_centroids: ::std::os::raw::c_int,
    #[doc = "< otherwise you get a warning"]
    pub min_points_per_centroid: ::std::os::raw::c_int,
    #[doc = "< to limit size of dataset"]
    pub max_points_per_centroid: ::std::os::raw::c_int,
    #[doc = "< seed for the random number generator"]
    pub seed: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_FaissClusteringParameters() {
    assert_eq!(
        ::std::mem::size_of::<FaissClusteringParameters>(),
        36usize,
        concat!("Size of: ", stringify!(FaissClusteringParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<FaissClusteringParameters>(),
        4usize,
        concat!("Alignment of ", stringify!(FaissClusteringParameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FaissClusteringParameters>())).niter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(niter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FaissClusteringParameters>())).nredo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(nredo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FaissClusteringParameters>())).verbose as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(verbose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FaissClusteringParameters>())).spherical as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(spherical)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FaissClusteringParameters>())).update_index as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(update_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FaissClusteringParameters>())).frozen_centroids as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(frozen_centroids)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FaissClusteringParameters>())).min_points_per_centroid
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(min_points_per_centroid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FaissClusteringParameters>())).max_points_per_centroid
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(max_points_per_centroid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FaissClusteringParameters>())).seed as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(seed)
        )
    );
}
extern "C" {
    #[doc = " Sets the ClusteringParameters object with reasonable defaults"]
    pub fn faiss_ClusteringParameters_init(params: *mut FaissClusteringParameters);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissClustering_H {
    _unused: [u8; 0],
}
pub type FaissClustering = FaissClustering_H;
extern "C" {
    pub fn faiss_Clustering_niter(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_nredo(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_verbose(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_spherical(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_update_index(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_frozen_centroids(arg1: *const FaissClustering)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_min_points_per_centroid(
        arg1: *const FaissClustering,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_max_points_per_centroid(
        arg1: *const FaissClustering,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_seed(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_d(arg1: *const FaissClustering) -> usize;
}
extern "C" {
    pub fn faiss_Clustering_k(arg1: *const FaissClustering) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissClusteringIterationStats_H {
    _unused: [u8; 0],
}
pub type FaissClusteringIterationStats = FaissClusteringIterationStats_H;
extern "C" {
    pub fn faiss_ClusteringIterationStats_obj(arg1: *const FaissClusteringIterationStats) -> f32;
}
extern "C" {
    pub fn faiss_ClusteringIterationStats_time(arg1: *const FaissClusteringIterationStats) -> f64;
}
extern "C" {
    pub fn faiss_ClusteringIterationStats_time_search(
        arg1: *const FaissClusteringIterationStats,
    ) -> f64;
}
extern "C" {
    pub fn faiss_ClusteringIterationStats_imbalance_factor(
        arg1: *const FaissClusteringIterationStats,
    ) -> f64;
}
extern "C" {
    pub fn faiss_ClusteringIterationStats_nsplit(
        arg1: *const FaissClusteringIterationStats,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " getter for centroids (size = k * d)"]
    pub fn faiss_Clustering_centroids(
        clustering: *mut FaissClustering,
        centroids: *mut *mut f32,
        size: *mut usize,
    );
}
extern "C" {
    #[doc = " getter for iteration stats"]
    pub fn faiss_Clustering_iteration_stats(
        clustering: *mut FaissClustering,
        iteration_stats: *mut *mut FaissClusteringIterationStats,
        size: *mut usize,
    );
}
extern "C" {
    #[doc = " the only mandatory parameters are k and d"]
    pub fn faiss_Clustering_new(
        p_clustering: *mut *mut FaissClustering,
        d: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_new_with_params(
        p_clustering: *mut *mut FaissClustering,
        d: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        cp: *const FaissClusteringParameters,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_train(
        clustering: *mut FaissClustering,
        n: idx_t,
        x: *const f32,
        index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_free(clustering: *mut FaissClustering);
}
extern "C" {
    #[doc = " simplified interface"]
    #[doc = ""]
    #[doc = " @param d dimension of the data"]
    #[doc = " @param n nb of training vectors"]
    #[doc = " @param k nb of output centroids"]
    #[doc = " @param x training set (size n * d)"]
    #[doc = " @param centroids output centroids (size k * d)"]
    #[doc = " @param q_error final quantization error"]
    #[doc = " @return error code"]
    pub fn faiss_kmeans_clustering(
        d: usize,
        n: usize,
        k: usize,
        x: *const f32,
        centroids: *mut f32,
        q_error: *mut f32,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexFlat = FaissIndex_H;
extern "C" {
    #[doc = " Opaque type for IndexFlat"]
    pub fn faiss_IndexFlat_new(p_index: *mut *mut FaissIndexFlat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexFlat_new_with(
        p_index: *mut *mut FaissIndexFlat,
        d: idx_t,
        metric: FaissMetricType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get a pointer to the index's internal data (the `xb` field). The outputs"]
    #[doc = " become invalid after any data addition or removal operation."]
    #[doc = ""]
    #[doc = " @param index   opaque pointer to index object"]
    #[doc = " @param p_xb    output, the pointer to the beginning of `xb`."]
    #[doc = " @param p_size  output, the current size of `sb` in number of float values."]
    pub fn faiss_IndexFlat_xb(index: *mut FaissIndexFlat, p_xb: *mut *mut f32, p_size: *mut usize);
}
extern "C" {
    pub fn faiss_IndexFlat_cast(arg1: *mut FaissIndex) -> *mut FaissIndexFlat;
}
extern "C" {
    pub fn faiss_IndexFlat_free(obj: *mut FaissIndexFlat);
}
extern "C" {
    #[doc = " compute distance with a subset of vectors"]
    #[doc = ""]
    #[doc = " @param index   opaque pointer to index object"]
    #[doc = " @param x       query vectors, size n * d"]
    #[doc = " @param labels  indices of the vectors that should be compared"]
    #[doc = "                for each query vector, size n * k"]
    #[doc = " @param distances"]
    #[doc = "                corresponding output distances, size n * k"]
    pub fn faiss_IndexFlat_compute_distance_subset(
        index: *mut FaissIndex,
        n: idx_t,
        x: *const f32,
        k: idx_t,
        distances: *mut f32,
        labels: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexFlatIP = FaissIndex_H;
extern "C" {
    #[doc = " Opaque type for IndexFlatIP"]
    pub fn faiss_IndexFlatIP_new(p_index: *mut *mut FaissIndexFlatIP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexFlatIP_new_with(
        p_index: *mut *mut FaissIndexFlatIP,
        d: idx_t,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexFlatL2 = FaissIndex_H;
extern "C" {
    #[doc = " Opaque type for IndexFlatL2"]
    pub fn faiss_IndexFlatL2_new(p_index: *mut *mut FaissIndexFlatL2) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexFlatL2_new_with(
        p_index: *mut *mut FaissIndexFlatL2,
        d: idx_t,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexFlatL2BaseShift = FaissIndex_H;
extern "C" {
    #[doc = " Opaque type for IndexFlatL2BaseShift"]
    #[doc = ""]
    #[doc = " same as an IndexFlatL2 but a value is subtracted from each distance"]
    pub fn faiss_IndexFlatL2BaseShift_new(
        p_index: *mut *mut FaissIndexFlatL2BaseShift,
        d: idx_t,
        nshift: usize,
        shift: *const f32,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexRefineFlat = FaissIndex_H;
extern "C" {
    #[doc = " Opaque type for IndexRefineFlat"]
    #[doc = ""]
    #[doc = " Index that queries in a base_index (a fast one) and refines the"]
    #[doc = " results with an exact search, hopefully improving the results."]
    pub fn faiss_IndexRefineFlat_new(
        p_index: *mut *mut FaissIndexRefineFlat,
        base_index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexRefineFlat_free(obj: *mut FaissIndexRefineFlat);
}
pub type FaissIndexFlat1D = FaissIndex_H;
extern "C" {
    #[doc = " Opaque type for IndexFlat1D"]
    #[doc = ""]
    #[doc = " optimized version for 1D \"vectors\""]
    pub fn faiss_IndexFlat1D_new(p_index: *mut *mut FaissIndexFlat1D) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexFlat1D_new_with(
        p_index: *mut *mut FaissIndexFlat1D,
        continuous_update: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexFlat1D_update_permutation(
        index: *mut FaissIndexFlat1D,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIndexIVFFlat_H {
    _unused: [u8; 0],
}
pub type FaissIndexIVFFlat = FaissIndexIVFFlat_H;
extern "C" {
    pub fn faiss_IndexIVFFlat_free(obj: *mut FaissIndexIVFFlat);
}
extern "C" {
    pub fn faiss_IndexIVFFlat_cast(arg1: *mut FaissIndex) -> *mut FaissIndexIVFFlat;
}
extern "C" {
    #[doc = " Inverted file with stored vectors. Here the inverted file"]
    #[doc = " pre-selects the vectors to be searched, but they are not otherwise"]
    #[doc = " encoded, the code array just contains the raw float entries."]
    pub fn faiss_IndexIVFFlat_new(p_index: *mut *mut FaissIndexIVFFlat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_new_with(
        p_index: *mut *mut FaissIndexIVFFlat,
        quantizer: *mut FaissIndex,
        d: usize,
        nlist: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_new_with_metric(
        p_index: *mut *mut FaissIndexIVFFlat,
        quantizer: *mut FaissIndex,
        d: usize,
        nlist: usize,
        metric: FaissMetricType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_add_core(
        index: *mut FaissIndexIVFFlat,
        n: idx_t,
        x: *const f32,
        xids: *const idx_t,
        precomputed_idx: *const i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Update a subset of vectors."]
    #[doc = ""]
    #[doc = " The index must have a direct_map"]
    #[doc = ""]
    #[doc = " @param nv     nb of vectors to update"]
    #[doc = " @param idx    vector indices to update, size nv"]
    #[doc = " @param v      vectors of new values, size nv*d"]
    pub fn faiss_IndexIVFFlat_update_vectors(
        index: *mut FaissIndexIVFFlat,
        nv: ::std::os::raw::c_int,
        idx: *mut idx_t,
        v: *const f32,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexIVF = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexIVF_free(obj: *mut FaissIndexIVF);
}
extern "C" {
    pub fn faiss_IndexIVF_cast(arg1: *mut FaissIndex) -> *mut FaissIndexIVF;
}
extern "C" {
    pub fn faiss_IndexIVF_nlist(arg1: *const FaissIndexIVF) -> usize;
}
extern "C" {
    pub fn faiss_IndexIVF_nprobe(arg1: *const FaissIndexIVF) -> usize;
}
extern "C" {
    pub fn faiss_IndexIVF_quantizer(arg1: *const FaissIndexIVF) -> *mut FaissIndex;
}
extern "C" {
    pub fn faiss_IndexIVF_quantizer_trains_alone(
        arg1: *const FaissIndexIVF,
    ) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn faiss_IndexIVF_own_fields(arg1: *const FaissIndexIVF) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " moves the entries from another dataset to self. On output,"]
    #[doc = " other is empty. add_id is added to all moved ids (for"]
    #[doc = " sequential ids, this would be this->ntotal"]
    pub fn faiss_IndexIVF_merge_from(
        index: *mut FaissIndexIVF,
        other: *mut FaissIndexIVF,
        add_id: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " copy a subset of the entries index to the other index"]
    #[doc = ""]
    #[doc = " if subset_type == 0: copies ids in [a1, a2)"]
    #[doc = " if subset_type == 1: copies ids if id % a1 == a2"]
    #[doc = " if subset_type == 2: copies inverted lists such that a1"]
    #[doc = "                      elements are left before and a2 elements are after"]
    pub fn faiss_IndexIVF_copy_subset_to(
        index: *const FaissIndexIVF,
        other: *mut FaissIndexIVF,
        subset_type: ::std::os::raw::c_int,
        a1: idx_t,
        a2: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " search a set of vectors, that are pre-quantized by the IVF"]
    #[doc = "  quantizer. Fill in the corresponding heaps with the query"]
    #[doc = "  results. search() calls this."]
    #[doc = ""]
    #[doc = " @param n      nb of vectors to query"]
    #[doc = " @param x      query vectors, size nx * d"]
    #[doc = " @param assign coarse quantization indices, size nx * nprobe"]
    #[doc = " @param centroid_dis"]
    #[doc = "               distances to coarse centroids, size nx * nprobe"]
    #[doc = " @param distance"]
    #[doc = "               output distances, size n * k"]
    #[doc = " @param labels output labels, size n * k"]
    #[doc = " @param store_pairs store inv list index + inv list offset"]
    #[doc = "                     instead in upper/lower 32 bit of result,"]
    #[doc = "                     instead of ids (used for reranking)."]
    pub fn faiss_IndexIVF_search_preassigned(
        index: *const FaissIndexIVF,
        n: idx_t,
        x: *const f32,
        k: idx_t,
        assign: *const idx_t,
        centroid_dis: *const f32,
        distances: *mut f32,
        labels: *mut idx_t,
        store_pairs: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVF_get_list_size(index: *const FaissIndexIVF, list_no: usize) -> usize;
}
extern "C" {
    #[doc = " intialize a direct map"]
    #[doc = ""]
    #[doc = " @param new_maintain_direct_map    if true, create a direct map,"]
    #[doc = "                                   else clear it"]
    pub fn faiss_IndexIVF_make_direct_map(
        index: *mut FaissIndexIVF,
        new_maintain_direct_map: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check the inverted lists' imbalance factor."]
    #[doc = ""]
    #[doc = " 1= perfectly balanced, >1: imbalanced"]
    pub fn faiss_IndexIVF_imbalance_factor(index: *const FaissIndexIVF) -> f64;
}
extern "C" {
    #[doc = " display some stats about the inverted lists of the index"]
    pub fn faiss_IndexIVF_print_stats(index: *const FaissIndexIVF);
}
extern "C" {
    #[doc = " Get the IDs in an inverted list. IDs are written to `invlist`, which must be large enough"]
    #[doc = " to accommodate the full list."]
    #[doc = ""]
    #[doc = " @param list_no the list ID"]
    #[doc = " @param invlist output pointer to a slice of memory, at least as long as the list's size"]
    #[doc = " @see faiss_IndexIVF_get_list_size(size_t)"]
    pub fn faiss_IndexIVF_invlists_get_ids(
        index: *const FaissIndexIVF,
        list_no: usize,
        invlist: *mut idx_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIndexIVFStats {
    pub nq: usize,
    pub nlist: usize,
    pub ndis: usize,
}
#[test]
fn bindgen_test_layout_FaissIndexIVFStats() {
    assert_eq!(
        ::std::mem::size_of::<FaissIndexIVFStats>(),
        24usize,
        concat!("Size of: ", stringify!(FaissIndexIVFStats))
    );
    assert_eq!(
        ::std::mem::align_of::<FaissIndexIVFStats>(),
        8usize,
        concat!("Alignment of ", stringify!(FaissIndexIVFStats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FaissIndexIVFStats>())).nq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissIndexIVFStats),
            "::",
            stringify!(nq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FaissIndexIVFStats>())).nlist as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissIndexIVFStats),
            "::",
            stringify!(nlist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FaissIndexIVFStats>())).ndis as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissIndexIVFStats),
            "::",
            stringify!(ndis)
        )
    );
}
extern "C" {
    pub fn faiss_IndexIVFStats_reset(stats: *mut FaissIndexIVFStats);
}
pub type FaissIndexLSH = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexLSH_free(obj: *mut FaissIndexLSH);
}
extern "C" {
    pub fn faiss_IndexLSH_cast(arg1: *mut FaissIndex) -> *mut FaissIndexLSH;
}
extern "C" {
    pub fn faiss_IndexLSH_nbits(arg1: *const FaissIndexLSH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexLSH_bytes_per_vec(arg1: *const FaissIndexLSH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexLSH_rotate_data(arg1: *const FaissIndexLSH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexLSH_train_thresholds(arg1: *const FaissIndexLSH) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The sign of each vector component is put in a binary signature"]
    pub fn faiss_IndexLSH_new(
        p_index: *mut *mut FaissIndexLSH,
        d: idx_t,
        nbits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexLSH_new_with_options(
        p_index: *mut *mut FaissIndexLSH,
        d: idx_t,
        nbits: ::std::os::raw::c_int,
        rotate_data: ::std::os::raw::c_int,
        train_thresholds: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIndexPreTransform_H {
    _unused: [u8; 0],
}
pub type FaissIndexPreTransform = FaissIndexPreTransform_H;
extern "C" {
    pub fn faiss_IndexPreTransform_free(obj: *mut FaissIndexPreTransform);
}
extern "C" {
    pub fn faiss_IndexPreTransform_cast(arg1: *mut FaissIndex) -> *mut FaissIndexPreTransform;
}
extern "C" {
    pub fn faiss_IndexPreTransform_index(arg1: *const FaissIndexPreTransform) -> *mut FaissIndex;
}
pub type FaissIndexShards = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexShards_own_fields(arg1: *const FaissIndexShards) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexShards_set_own_fields(
        arg1: *mut FaissIndexShards,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn faiss_IndexShards_successive_ids(arg1: *const FaissIndexShards)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexShards_set_successive_ids(
        arg1: *mut FaissIndexShards,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Index that concatenates the results from several sub-indexes"]
    pub fn faiss_IndexShards_new(
        p_index: *mut *mut FaissIndexShards,
        d: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexShards_new_with_options(
        p_index: *mut *mut FaissIndexShards,
        d: idx_t,
        threaded: ::std::os::raw::c_int,
        successive_ids: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexShards_add_shard(
        index: *mut FaissIndexShards,
        shard: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " update metric_type and ntotal"]
    pub fn faiss_IndexShards_sync_with_shard_indexes(
        index: *mut FaissIndexShards,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexShards_at(
        index: *mut FaissIndexShards,
        i: ::std::os::raw::c_int,
    ) -> *mut FaissIndex;
}
pub type FaissIndexIDMap = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexIDMap_own_fields(arg1: *const FaissIndexIDMap) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIDMap_set_own_fields(arg1: *mut FaissIndexIDMap, arg2: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Index that translates search results to ids"]
    pub fn faiss_IndexIDMap_new(
        p_index: *mut *mut FaissIndexIDMap,
        index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get a pointer to the index map's internal ID vector (the `id_map` field). The"]
    #[doc = " outputs of this function become invalid after any operation that can modify the index."]
    #[doc = ""]
    #[doc = " @param index   opaque pointer to index object"]
    #[doc = " @param p_id_map    output, the pointer to the beginning of `id_map`."]
    #[doc = " @param p_size  output, the current length of `id_map`."]
    pub fn faiss_IndexIDMap_id_map(
        index: *mut FaissIndexIDMap,
        p_id_map: *mut *mut idx_t,
        p_size: *mut usize,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIndexIDMap_H {
    _unused: [u8; 0],
}
pub type FaissIndexIDMap2 = FaissIndexIDMap_H;
extern "C" {
    #[doc = " same as IndexIDMap but also provides an efficient reconstruction"]
    #[doc = "implementation via a 2-way index"]
    pub fn faiss_IndexIDMap2_new(
        p_index: *mut *mut FaissIndexIDMap2,
        index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " make the rev_map from scratch"]
    pub fn faiss_IndexIDMap2_construct_rev_map(
        index: *mut FaissIndexIDMap2,
    ) -> ::std::os::raw::c_int;
}
pub type FILE = [u64; 27usize];
extern "C" {
    #[doc = " Clone an index. This is equivalent to `faiss::clone_index`"]
    pub fn faiss_clone_index(
        arg1: *const FaissIndex,
        p_out: *mut *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
#[doc = " No error"]
pub const FaissErrorCode_OK: FaissErrorCode = 0;
#[doc = " Any exception other than Faiss or standard C++ library exceptions"]
pub const FaissErrorCode_UNKNOWN_EXCEPT: FaissErrorCode = -1;
#[doc = " Faiss library exception"]
pub const FaissErrorCode_FAISS_EXCEPT: FaissErrorCode = -2;
#[doc = " Standard C++ library exception"]
pub const FaissErrorCode_STD_EXCEPT: FaissErrorCode = -4;
#[doc = " An error code which depends on the exception thrown from the previous"]
#[doc = " operation. See `faiss_get_last_error` to retrieve the error message."]
pub type FaissErrorCode = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Get the error message of the last failed operation performed by Faiss."]
    #[doc = " The given pointer is only invalid until another Faiss function is"]
    #[doc = " called."]
    pub fn faiss_get_last_error() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn faiss_RangeSearchResult_nq(arg1: *const FaissRangeSearchResult) -> usize;
}
extern "C" {
    pub fn faiss_RangeSearchResult_new(
        p_rsr: *mut *mut FaissRangeSearchResult,
        nq: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_RangeSearchResult_new_with(
        p_rsr: *mut *mut FaissRangeSearchResult,
        nq: idx_t,
        alloc_lims: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " called when lims contains the nb of elements result entries"]
    #[doc = " for each query"]
    pub fn faiss_RangeSearchResult_do_allocation(
        rsr: *mut FaissRangeSearchResult,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_RangeSearchResult_free(obj: *mut FaissRangeSearchResult);
}
extern "C" {
    pub fn faiss_RangeSearchResult_buffer_size(arg1: *const FaissRangeSearchResult) -> usize;
}
extern "C" {
    #[doc = " getter for lims: size (nq + 1)"]
    pub fn faiss_RangeSearchResult_lims(rsr: *mut FaissRangeSearchResult, lims: *mut *mut usize);
}
extern "C" {
    #[doc = " getter for labels and respective distances (not sorted):"]
    #[doc = " result for query i is labels[lims[i]:lims[i+1]]"]
    pub fn faiss_RangeSearchResult_labels(
        rsr: *mut FaissRangeSearchResult,
        labels: *mut *mut idx_t,
        distances: *mut *mut f32,
    );
}
extern "C" {
    pub fn faiss_IDSelector_free(obj: *mut FaissIDSelector);
}
extern "C" {
    #[doc = " Encapsulates a set of ids to remove."]
    pub fn faiss_IDSelector_is_member(
        sel: *const FaissIDSelector,
        id: idx_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIDSelectorRange_H {
    _unused: [u8; 0],
}
pub type FaissIDSelectorRange = FaissIDSelectorRange_H;
extern "C" {
    pub fn faiss_IDSelectorRange_free(obj: *mut FaissIDSelectorRange);
}
extern "C" {
    pub fn faiss_IDSelectorRange_imin(arg1: *const FaissIDSelectorRange) -> idx_t;
}
extern "C" {
    pub fn faiss_IDSelectorRange_imax(arg1: *const FaissIDSelectorRange) -> idx_t;
}
extern "C" {
    #[doc = " remove ids between [imni, imax)"]
    pub fn faiss_IDSelectorRange_new(
        p_sel: *mut *mut FaissIDSelectorRange,
        imin: idx_t,
        imax: idx_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIDSelectorBatch_H {
    _unused: [u8; 0],
}
pub type FaissIDSelectorBatch = FaissIDSelectorBatch_H;
extern "C" {
    pub fn faiss_IDSelectorBatch_nbits(arg1: *const FaissIDSelectorBatch) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IDSelectorBatch_mask(arg1: *const FaissIDSelectorBatch) -> idx_t;
}
extern "C" {
    #[doc = " Remove ids from a set. Repetitions of ids in the indices set"]
    #[doc = " passed to the constructor does not hurt performance. The hash"]
    #[doc = " function used for the bloom filter and GCC's implementation of"]
    #[doc = " unordered_set are just the least significant bits of the id. This"]
    #[doc = " works fine for random ids or ids in sequences but will produce many"]
    #[doc = " hash collisions if lsb's are always the same"]
    pub fn faiss_IDSelectorBatch_new(
        p_sel: *mut *mut FaissIDSelectorBatch,
        n: usize,
        indices: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissBufferList_H {
    _unused: [u8; 0],
}
pub type FaissBufferList = FaissBufferList_H;
extern "C" {
    pub fn faiss_BufferList_free(obj: *mut FaissBufferList);
}
extern "C" {
    pub fn faiss_BufferList_buffer_size(arg1: *const FaissBufferList) -> usize;
}
extern "C" {
    pub fn faiss_BufferList_wp(arg1: *const FaissBufferList) -> usize;
}
#[doc = " List of temporary buffers used to store results before they are"]
#[doc = "  copied to the RangeSearchResult object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissBuffer {
    pub ids: *mut idx_t,
    pub dis: *mut f32,
}
#[test]
fn bindgen_test_layout_FaissBuffer() {
    assert_eq!(
        ::std::mem::size_of::<FaissBuffer>(),
        16usize,
        concat!("Size of: ", stringify!(FaissBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<FaissBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(FaissBuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FaissBuffer>())).ids as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissBuffer),
            "::",
            stringify!(ids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FaissBuffer>())).dis as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissBuffer),
            "::",
            stringify!(dis)
        )
    );
}
extern "C" {
    pub fn faiss_BufferList_append_buffer(bl: *mut FaissBufferList) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_BufferList_new(
        p_bl: *mut *mut FaissBufferList,
        buffer_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_BufferList_add(
        bl: *mut FaissBufferList,
        id: idx_t,
        dis: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " copy elemnts ofs:ofs+n-1 seen as linear data in the buffers to"]
    #[doc = " tables dest_ids, dest_dis"]
    pub fn faiss_BufferList_copy_range(
        bl: *mut FaissBufferList,
        ofs: usize,
        n: usize,
        dest_ids: *mut idx_t,
        dest_dis: *mut f32,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissRangeSearchPartialResult_H {
    _unused: [u8; 0],
}
pub type FaissRangeSearchPartialResult = FaissRangeSearchPartialResult_H;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissRangeQueryResult_H {
    _unused: [u8; 0],
}
pub type FaissRangeQueryResult = FaissRangeQueryResult_H;
extern "C" {
    pub fn faiss_RangeQueryResult_qno(arg1: *const FaissRangeQueryResult) -> idx_t;
}
extern "C" {
    pub fn faiss_RangeQueryResult_nres(arg1: *const FaissRangeQueryResult) -> usize;
}
extern "C" {
    pub fn faiss_RangeQueryResult_pres(
        arg1: *const FaissRangeQueryResult,
    ) -> *mut FaissRangeSearchPartialResult;
}
extern "C" {
    #[doc = " result structure for a single query"]
    pub fn faiss_RangeQueryResult_add(
        qr: *mut FaissRangeQueryResult,
        dis: f32,
        id: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_RangeSearchPartialResult_res(
        arg1: *const FaissRangeSearchPartialResult,
    ) -> *mut FaissRangeSearchResult;
}
extern "C" {
    pub fn faiss_RangeSearchPartialResult_new(
        p_res: *mut *mut FaissRangeSearchPartialResult,
        res_in: *mut FaissRangeSearchResult,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_RangeSearchPartialResult_finalize(
        res: *mut FaissRangeSearchPartialResult,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " called by range_search before do_allocation"]
    pub fn faiss_RangeSearchPartialResult_set_lims(
        res: *mut FaissRangeSearchPartialResult,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_RangeSearchPartialResult_new_result(
        res: *mut FaissRangeSearchPartialResult,
        qno: idx_t,
        qr: *mut *mut FaissRangeQueryResult,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissDistanceComputer_H {
    _unused: [u8; 0],
}
pub type FaissDistanceComputer = FaissDistanceComputer_H;
extern "C" {
    #[doc = " called before computing distances"]
    pub fn faiss_DistanceComputer_set_query(
        dc: *mut FaissDistanceComputer,
        x: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compute distance of vector i to current query."]
    #[doc = " This function corresponds to the function call operator: DistanceComputer::operator()"]
    pub fn faiss_DistanceComputer_vector_to_query_dis(
        dc: *mut FaissDistanceComputer,
        i: idx_t,
        qd: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " compute distance between two stored vectors"]
    pub fn faiss_DistanceComputer_symmetric_dis(
        dc: *mut FaissDistanceComputer,
        i: idx_t,
        j: idx_t,
        vd: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_DistanceComputer_free(obj: *mut FaissDistanceComputer);
}
extern "C" {
    #[doc = " Build and index with the sequence of processing steps described in"]
    #[doc = "  the string."]
    pub fn faiss_index_factory(
        p_index: *mut *mut FaissIndex,
        d: ::std::os::raw::c_int,
        description: *const ::std::os::raw::c_char,
        metric: FaissMetricType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write index to a file."]
    #[doc = " This is equivalent to `faiss::write_index` when a file descriptor is provided."]
    pub fn faiss_write_index(idx: *const FaissIndex, f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write index to a file."]
    #[doc = " This is equivalent to `faiss::write_index` when a file path is provided."]
    pub fn faiss_write_index_fname(
        idx: *const FaissIndex,
        fname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read index from a file."]
    #[doc = " This is equivalent to `faiss:read_index` when a file descriptor is given."]
    pub fn faiss_read_index(
        f: *mut FILE,
        io_flags: ::std::os::raw::c_int,
        p_out: *mut *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read index from a file."]
    #[doc = " This is equivalent to `faiss:read_index` when a file path is given."]
    pub fn faiss_read_index_fname(
        fname: *const ::std::os::raw::c_char,
        io_flags: ::std::os::raw::c_int,
        p_out: *mut *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
