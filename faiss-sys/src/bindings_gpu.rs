/* automatically generated by rust-bindgen 0.71.1 */

#[doc = r" If Bindgen could only determine the size and alignment of a"]
#[doc = r" type, it is represented like this."]
#[derive(PartialEq, Copy, Clone, Debug, Hash)]
#[repr(C)]
pub struct __BindgenOpaqueArray<T: Copy, const N: usize>(pub [T; N]);
impl<T: Copy + Default, const N: usize> Default for __BindgenOpaqueArray<T, N> {
    fn default() -> Self {
        Self([<T as Default>::default(); N])
    }
}
pub type faiss_idx_t = i64;
pub type idx_t = faiss_idx_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissRangeSearchResult_H {
    _unused: [u8; 0],
}
pub type FaissRangeSearchResult = FaissRangeSearchResult_H;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIDSelector_H {
    _unused: [u8; 0],
}
pub type FaissIDSelector = FaissIDSelector_H;
#[doc = "< maximum inner product search"]
pub const FaissMetricType_METRIC_INNER_PRODUCT: FaissMetricType = 0;
#[doc = "< squared L2 search"]
pub const FaissMetricType_METRIC_L2: FaissMetricType = 1;
#[doc = "< L1 (aka cityblock)"]
pub const FaissMetricType_METRIC_L1: FaissMetricType = 2;
#[doc = "< infinity distance"]
pub const FaissMetricType_METRIC_Linf: FaissMetricType = 3;
#[doc = "< L_p distance, p is given by metric_arg"]
pub const FaissMetricType_METRIC_Lp: FaissMetricType = 4;
#[doc = " some additional metrics defined in scipy.spatial.distance"]
pub const FaissMetricType_METRIC_Canberra: FaissMetricType = 20;
#[doc = " some additional metrics defined in scipy.spatial.distance"]
pub const FaissMetricType_METRIC_BrayCurtis: FaissMetricType = 21;
#[doc = " some additional metrics defined in scipy.spatial.distance"]
pub const FaissMetricType_METRIC_JensenShannon: FaissMetricType = 22;
#[doc = " Some algorithms support both an inner product version and a L2 search\n version."]
pub type FaissMetricType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissSearchParameters_H {
    _unused: [u8; 0],
}
pub type FaissSearchParameters = FaissSearchParameters_H;
unsafe extern "C" {
    pub fn faiss_SearchParameters_free(obj: *mut FaissSearchParameters);
}
unsafe extern "C" {
    pub fn faiss_SearchParameters_new(
        p_sp: *mut *mut FaissSearchParameters,
        sel: *mut FaissIDSelector,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIndex_H {
    _unused: [u8; 0],
}
pub type FaissIndex = FaissIndex_H;
unsafe extern "C" {
    pub fn faiss_Index_free(obj: *mut FaissIndex);
}
unsafe extern "C" {
    pub fn faiss_Index_d(arg1: *const FaissIndex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_Index_is_trained(arg1: *const FaissIndex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_Index_ntotal(arg1: *const FaissIndex) -> idx_t;
}
unsafe extern "C" {
    pub fn faiss_Index_metric_type(arg1: *const FaissIndex) -> FaissMetricType;
}
unsafe extern "C" {
    pub fn faiss_Index_verbose(arg1: *const FaissIndex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_Index_set_verbose(arg1: *mut FaissIndex, arg2: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Perform training on a representative set of vectors\n\n @param index  opaque pointer to index object\n @param n      nb of training vectors\n @param x      training vectors, size n * d"]
    pub fn faiss_Index_train(
        index: *mut FaissIndex,
        n: idx_t,
        x: *const f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add n vectors of dimension d to the index.\n\n Vectors are implicitly assigned labels ntotal .. ntotal + n - 1\n This function slices the input vectors in chunks smaller than\n blocksize_add and calls add_core.\n @param index  opaque pointer to index object\n @param x      input matrix, size n * d"]
    pub fn faiss_Index_add(
        index: *mut FaissIndex,
        n: idx_t,
        x: *const f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Same as add, but stores xids instead of sequential ids.\n\n The default implementation fails with an assertion, as it is\n not supported by all indexes.\n\n @param index  opaque pointer to index object\n @param xids   if non-null, ids to store for the vectors (size n)"]
    pub fn faiss_Index_add_with_ids(
        index: *mut FaissIndex,
        n: idx_t,
        x: *const f32,
        xids: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " query n vectors of dimension d to the index.\n\n return at most k vectors. If there are not enough results for a\n query, the result array is padded with -1s.\n\n @param index       opaque pointer to index object\n @param x           input vectors to search, size n * d\n @param labels      output labels of the NNs, size n*k\n @param distances   output pairwise distances, size n*k"]
    pub fn faiss_Index_search(
        index: *const FaissIndex,
        n: idx_t,
        x: *const f32,
        k: idx_t,
        distances: *mut f32,
        labels: *mut idx_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " query n vectors of dimension d with search parameters to the index.\n\n return at most k vectors. If there are not enough results for a query,\n the result is padded with -1s.\n\n @param index       opaque pointer to index object\n @param x           input vectors to search, size n * d\n @param params      input params to modify how search is done\n @param labels      output labels of the NNs, size n*k\n @param distances   output pairwise distances, size n*k"]
    pub fn faiss_Index_search_with_params(
        index: *const FaissIndex,
        n: idx_t,
        x: *const f32,
        k: idx_t,
        params: *const FaissSearchParameters,
        distances: *mut f32,
        labels: *mut idx_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " query n vectors of dimension d to the index.\n\n return all vectors with distance < radius. Note that many\n indexes do not implement the range_search (only the k-NN search\n is mandatory).\n\n @param index       opaque pointer to index object\n @param x           input vectors to search, size n * d\n @param radius      search radius\n @param result      result table"]
    pub fn faiss_Index_range_search(
        index: *const FaissIndex,
        n: idx_t,
        x: *const f32,
        radius: f32,
        result: *mut FaissRangeSearchResult,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " return the indexes of the k vectors closest to the query x.\n\n This function is identical as search but only return labels of neighbors.\n @param index       opaque pointer to index object\n @param x           input vectors to search, size n * d\n @param labels      output labels of the NNs, size n*k"]
    pub fn faiss_Index_assign(
        index: *mut FaissIndex,
        n: idx_t,
        x: *const f32,
        labels: *mut idx_t,
        k: idx_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " removes all elements from the database.\n @param index       opaque pointer to index object"]
    pub fn faiss_Index_reset(index: *mut FaissIndex) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " removes IDs from the index. Not supported by all indexes\n @param index       opaque pointer to index object\n @param nremove     output for the number of IDs removed"]
    pub fn faiss_Index_remove_ids(
        index: *mut FaissIndex,
        sel: *const FaissIDSelector,
        n_removed: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Reconstruct a stored vector (or an approximation if lossy coding)\n\n this function may not be defined for some indexes\n @param index       opaque pointer to index object\n @param key         id of the vector to reconstruct\n @param recons      reconstructed vector (size d)"]
    pub fn faiss_Index_reconstruct(
        index: *const FaissIndex,
        key: idx_t,
        recons: *mut f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Reconstruct vectors i0 to i0 + ni - 1\n\n this function may not be defined for some indexes\n @param index       opaque pointer to index object\n @param recons      reconstructed vector (size ni * d)"]
    pub fn faiss_Index_reconstruct_n(
        index: *const FaissIndex,
        i0: idx_t,
        ni: idx_t,
        recons: *mut f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Computes a residual vector after indexing encoding.\n\n The residual vector is the difference between a vector and the\n reconstruction that can be decoded from its representation in\n the index. The residual can be used for multiple-stage indexing\n methods, like IndexIVF's methods.\n\n @param index       opaque pointer to index object\n @param x           input vector, size d\n @param residual    output residual vector, size d\n @param key         encoded index, as returned by search and assign"]
    pub fn faiss_Index_compute_residual(
        index: *const FaissIndex,
        x: *const f32,
        residual: *mut f32,
        key: idx_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Computes a residual vector after indexing encoding.\n\n The residual vector is the difference between a vector and the\n reconstruction that can be decoded from its representation in\n the index. The residual can be used for multiple-stage indexing\n methods, like IndexIVF's methods.\n\n @param index       opaque pointer to index object\n @param n           number of vectors\n @param x           input vector, size (n x d)\n @param residuals    output residual vectors, size (n x d)\n @param keys         encoded index, as returned by search and assign"]
    pub fn faiss_Index_compute_residual_n(
        index: *const FaissIndex,
        n: idx_t,
        x: *const f32,
        residuals: *mut f32,
        keys: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " The size of the produced codes in bytes.\n\n @param index   opaque pointer to index object\n @param size    the returned size in bytes"]
    pub fn faiss_Index_sa_code_size(
        index: *const FaissIndex,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " encode a set of vectors\n\n @param index   opaque pointer to index object\n @param n       number of vectors\n @param x       input vectors, size n * d\n @param bytes   output encoded vectors, size n * sa_code_size()"]
    pub fn faiss_Index_sa_encode(
        index: *const FaissIndex,
        n: idx_t,
        x: *const f32,
        bytes: *mut u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " decode a set of vectors\n\n @param index   opaque pointer to index object\n @param n       number of vectors\n @param bytes   input encoded vectors, size n * sa_code_size()\n @param x       output vectors, size n * d"]
    pub fn faiss_Index_sa_decode(
        index: *const FaissIndex,
        n: idx_t,
        bytes: *const u8,
        x: *mut f32,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissParameterRange_H {
    _unused: [u8; 0],
}
pub type FaissParameterRange = FaissParameterRange_H;
unsafe extern "C" {
    pub fn faiss_ParameterRange_name(
        arg1: *const FaissParameterRange,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Getter for the values in the range. The output values are invalidated\n upon any other modification of the range."]
    pub fn faiss_ParameterRange_values(
        arg1: *mut FaissParameterRange,
        arg2: *mut *mut f64,
        arg3: *mut usize,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissParameterSpace_H {
    _unused: [u8; 0],
}
pub type FaissParameterSpace = FaissParameterSpace_H;
unsafe extern "C" {
    pub fn faiss_ParameterSpace_free(obj: *mut FaissParameterSpace);
}
unsafe extern "C" {
    #[doc = " Parameter space default constructor"]
    pub fn faiss_ParameterSpace_new(space: *mut *mut FaissParameterSpace) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " nb of combinations, = product of values sizes"]
    pub fn faiss_ParameterSpace_n_combinations(arg1: *const FaissParameterSpace) -> usize;
}
unsafe extern "C" {
    #[doc = " get string representation of the combination\n by writing it to the given character buffer.\n A buffer size of 1000 ensures that the full name is collected."]
    pub fn faiss_ParameterSpace_combination_name(
        arg1: *const FaissParameterSpace,
        arg2: usize,
        arg3: *mut ::std::os::raw::c_char,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " set a combination of parameters described by a string"]
    pub fn faiss_ParameterSpace_set_index_parameters(
        arg1: *const FaissParameterSpace,
        arg2: *mut FaissIndex,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " set a combination of parameters on an index"]
    pub fn faiss_ParameterSpace_set_index_parameters_cno(
        arg1: *const FaissParameterSpace,
        arg2: *mut FaissIndex,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " set one of the parameters"]
    pub fn faiss_ParameterSpace_set_index_parameter(
        arg1: *const FaissParameterSpace,
        arg2: *mut FaissIndex,
        arg3: *const ::std::os::raw::c_char,
        arg4: f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " print a description on stdout"]
    pub fn faiss_ParameterSpace_display(arg1: *const FaissParameterSpace);
}
unsafe extern "C" {
    #[doc = " add a new parameter (or return it if it exists)"]
    pub fn faiss_ParameterSpace_add_range(
        arg1: *mut FaissParameterSpace,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut FaissParameterRange,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Class for the clustering parameters. Can be passed to the\n constructor of the Clustering object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissClusteringParameters {
    #[doc = "< clustering iterations"]
    pub niter: ::std::os::raw::c_int,
    #[doc = "< redo clustering this many times and keep best"]
    pub nredo: ::std::os::raw::c_int,
    #[doc = "< (bool)"]
    pub verbose: ::std::os::raw::c_int,
    #[doc = "< (bool) do we want normalized centroids?"]
    pub spherical: ::std::os::raw::c_int,
    #[doc = "< (bool) round centroids coordinates to integer"]
    pub int_centroids: ::std::os::raw::c_int,
    #[doc = "< (bool) update index after each iteration?"]
    pub update_index: ::std::os::raw::c_int,
    #[doc = "< (bool) use the centroids provided as input and do\n< not change them during iterations"]
    pub frozen_centroids: ::std::os::raw::c_int,
    #[doc = "< otherwise you get a warning"]
    pub min_points_per_centroid: ::std::os::raw::c_int,
    #[doc = "< to limit size of dataset"]
    pub max_points_per_centroid: ::std::os::raw::c_int,
    #[doc = "< seed for the random number generator"]
    pub seed: ::std::os::raw::c_int,
    #[doc = "< how many vectors at a time to decode"]
    pub decode_block_size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FaissClusteringParameters"]
        [::std::mem::size_of::<FaissClusteringParameters>() - 48usize];
    ["Alignment of FaissClusteringParameters"]
        [::std::mem::align_of::<FaissClusteringParameters>() - 8usize];
    ["Offset of field: FaissClusteringParameters::niter"]
        [::std::mem::offset_of!(FaissClusteringParameters, niter) - 0usize];
    ["Offset of field: FaissClusteringParameters::nredo"]
        [::std::mem::offset_of!(FaissClusteringParameters, nredo) - 4usize];
    ["Offset of field: FaissClusteringParameters::verbose"]
        [::std::mem::offset_of!(FaissClusteringParameters, verbose) - 8usize];
    ["Offset of field: FaissClusteringParameters::spherical"]
        [::std::mem::offset_of!(FaissClusteringParameters, spherical) - 12usize];
    ["Offset of field: FaissClusteringParameters::int_centroids"]
        [::std::mem::offset_of!(FaissClusteringParameters, int_centroids) - 16usize];
    ["Offset of field: FaissClusteringParameters::update_index"]
        [::std::mem::offset_of!(FaissClusteringParameters, update_index) - 20usize];
    ["Offset of field: FaissClusteringParameters::frozen_centroids"]
        [::std::mem::offset_of!(FaissClusteringParameters, frozen_centroids) - 24usize];
    ["Offset of field: FaissClusteringParameters::min_points_per_centroid"]
        [::std::mem::offset_of!(FaissClusteringParameters, min_points_per_centroid) - 28usize];
    ["Offset of field: FaissClusteringParameters::max_points_per_centroid"]
        [::std::mem::offset_of!(FaissClusteringParameters, max_points_per_centroid) - 32usize];
    ["Offset of field: FaissClusteringParameters::seed"]
        [::std::mem::offset_of!(FaissClusteringParameters, seed) - 36usize];
    ["Offset of field: FaissClusteringParameters::decode_block_size"]
        [::std::mem::offset_of!(FaissClusteringParameters, decode_block_size) - 40usize];
};
unsafe extern "C" {
    #[doc = " Sets the ClusteringParameters object with reasonable defaults"]
    pub fn faiss_ClusteringParameters_init(params: *mut FaissClusteringParameters);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissClustering_H {
    _unused: [u8; 0],
}
pub type FaissClustering = FaissClustering_H;
unsafe extern "C" {
    pub fn faiss_Clustering_niter(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_Clustering_nredo(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_Clustering_verbose(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_Clustering_spherical(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_Clustering_int_centroids(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_Clustering_update_index(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_Clustering_frozen_centroids(arg1: *const FaissClustering)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_Clustering_min_points_per_centroid(
        arg1: *const FaissClustering,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_Clustering_max_points_per_centroid(
        arg1: *const FaissClustering,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_Clustering_seed(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_Clustering_decode_block_size(arg1: *const FaissClustering) -> usize;
}
unsafe extern "C" {
    pub fn faiss_Clustering_d(arg1: *const FaissClustering) -> usize;
}
unsafe extern "C" {
    pub fn faiss_Clustering_k(arg1: *const FaissClustering) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissClusteringIterationStats_H {
    _unused: [u8; 0],
}
pub type FaissClusteringIterationStats = FaissClusteringIterationStats_H;
unsafe extern "C" {
    pub fn faiss_ClusteringIterationStats_obj(arg1: *const FaissClusteringIterationStats) -> f32;
}
unsafe extern "C" {
    pub fn faiss_ClusteringIterationStats_time(arg1: *const FaissClusteringIterationStats) -> f64;
}
unsafe extern "C" {
    pub fn faiss_ClusteringIterationStats_time_search(
        arg1: *const FaissClusteringIterationStats,
    ) -> f64;
}
unsafe extern "C" {
    pub fn faiss_ClusteringIterationStats_imbalance_factor(
        arg1: *const FaissClusteringIterationStats,
    ) -> f64;
}
unsafe extern "C" {
    pub fn faiss_ClusteringIterationStats_nsplit(
        arg1: *const FaissClusteringIterationStats,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " getter for centroids (size = k * d)"]
    pub fn faiss_Clustering_centroids(
        clustering: *mut FaissClustering,
        centroids: *mut *mut f32,
        size: *mut usize,
    );
}
unsafe extern "C" {
    #[doc = " getter for iteration stats"]
    pub fn faiss_Clustering_iteration_stats(
        clustering: *mut FaissClustering,
        iteration_stats: *mut *mut FaissClusteringIterationStats,
        size: *mut usize,
    );
}
unsafe extern "C" {
    #[doc = " the only mandatory parameters are k and d"]
    pub fn faiss_Clustering_new(
        p_clustering: *mut *mut FaissClustering,
        d: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_Clustering_new_with_params(
        p_clustering: *mut *mut FaissClustering,
        d: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        cp: *const FaissClusteringParameters,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_Clustering_train(
        clustering: *mut FaissClustering,
        n: idx_t,
        x: *const f32,
        index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_Clustering_free(clustering: *mut FaissClustering);
}
unsafe extern "C" {
    #[doc = " simplified interface\n\n @param d dimension of the data\n @param n nb of training vectors\n @param k nb of output centroids\n @param x training set (size n * d)\n @param centroids output centroids (size k * d)\n @param q_error final quantization error\n @return error code"]
    pub fn faiss_kmeans_clustering(
        d: usize,
        n: usize,
        k: usize,
        x: *const f32,
        centroids: *mut f32,
        q_error: *mut f32,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIndexBinary_H {
    _unused: [u8; 0],
}
pub type FaissIndexBinary = FaissIndexBinary_H;
unsafe extern "C" {
    pub fn faiss_IndexBinary_free(obj: *mut FaissIndexBinary);
}
unsafe extern "C" {
    pub fn faiss_IndexBinary_d(arg1: *const FaissIndexBinary) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexBinary_is_trained(arg1: *const FaissIndexBinary) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexBinary_ntotal(arg1: *const FaissIndexBinary) -> idx_t;
}
unsafe extern "C" {
    pub fn faiss_IndexBinary_metric_type(arg1: *const FaissIndexBinary) -> FaissMetricType;
}
unsafe extern "C" {
    pub fn faiss_IndexBinary_verbose(arg1: *const FaissIndexBinary) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexBinary_set_verbose(arg1: *mut FaissIndexBinary, arg2: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Perform training on a representative set of vectors\n\n @param index  opaque pointer to index object\n @param n      nb of training vectors\n @param x      training vectors, size n * d"]
    pub fn faiss_IndexBinary_train(
        index: *mut FaissIndexBinary,
        n: idx_t,
        x: *const u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add n vectors of dimension d to the index.\n\n Vectors are implicitly assigned labels ntotal .. ntotal + n - 1\n This function slices the input vectors in chunks smaller than\n blocksize_add and calls add_core.\n @param index  opaque pointer to index object\n @param x      input matrix, size n * d"]
    pub fn faiss_IndexBinary_add(
        index: *mut FaissIndexBinary,
        n: idx_t,
        x: *const u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Same as add, but stores xids instead of sequential ids.\n\n The default implementation fails with an assertion, as it is\n not supported by all indexes.\n\n @param index  opaque pointer to index object\n @param xids   if non-null, ids to store for the vectors (size n)"]
    pub fn faiss_IndexBinary_add_with_ids(
        index: *mut FaissIndexBinary,
        n: idx_t,
        x: *const u8,
        xids: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " query n vectors of dimension d to the index.\n\n return at most k vectors. If there are not enough results for a\n query, the result array is padded with -1s.\n\n @param index       opaque pointer to index object\n @param x           input vectors to search, size n * d\n @param labels      output labels of the NNs, size n*k\n @param distances   output pairwise distances, size n*k"]
    pub fn faiss_IndexBinary_search(
        index: *const FaissIndexBinary,
        n: idx_t,
        x: *const u8,
        k: idx_t,
        distances: *mut i32,
        labels: *mut idx_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " query n vectors of dimension d to the index.\n\n return all vectors with distance < radius. Note that many\n indexes do not implement the range_search (only the k-NN search\n is mandatory).\n\n @param index       opaque pointer to index object\n @param x           input vectors to search, size n * d\n @param radius      search radius\n @param result      result table"]
    pub fn faiss_IndexBinary_range_search(
        index: *const FaissIndexBinary,
        n: idx_t,
        x: *const u8,
        radius: ::std::os::raw::c_int,
        result: *mut FaissRangeSearchResult,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " return the indexes of the k vectors closest to the query x.\n\n This function is identical as search but only return labels of neighbors.\n @param index       opaque pointer to index object\n @param x           input vectors to search, size n * d\n @param labels      output labels of the NNs, size n*k"]
    pub fn faiss_IndexBinary_assign(
        index: *mut FaissIndexBinary,
        n: idx_t,
        x: *const u8,
        labels: *mut idx_t,
        k: idx_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " removes all elements from the database.\n @param index       opaque pointer to index object"]
    pub fn faiss_IndexBinary_reset(index: *mut FaissIndexBinary) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " removes IDs from the index. Not supported by all indexes\n @param index       opaque pointer to index object\n @param nremove     output for the number of IDs removed"]
    pub fn faiss_IndexBinary_remove_ids(
        index: *mut FaissIndexBinary,
        sel: *const FaissIDSelector,
        n_removed: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Reconstruct a stored vector (or an approximation if lossy coding)\n\n this function may not be defined for some indexes\n @param index       opaque pointer to index object\n @param key         id of the vector to reconstruct\n @param recons      reconstructed vector (size d)"]
    pub fn faiss_IndexBinary_reconstruct(
        index: *const FaissIndexBinary,
        key: idx_t,
        recons: *mut u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Reconstruct vectors i0 to i0 + ni - 1\n\n this function may not be defined for some indexes\n @param index       opaque pointer to index object\n @param recons      reconstructed vector (size ni * d)"]
    pub fn faiss_IndexBinary_reconstruct_n(
        index: *const FaissIndexBinary,
        i0: idx_t,
        ni: idx_t,
        recons: *mut u8,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexFlat = FaissIndex_H;
unsafe extern "C" {
    #[doc = " Opaque type for IndexFlat"]
    pub fn faiss_IndexFlat_new(p_index: *mut *mut FaissIndexFlat) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexFlat_new_with(
        p_index: *mut *mut FaissIndexFlat,
        d: idx_t,
        metric: FaissMetricType,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get a pointer to the index's internal data (the `xb` field). The outputs\n become invalid after any data addition or removal operation.\n\n @param index   opaque pointer to index object\n @param p_xb    output, the pointer to the beginning of `xb`.\n @param p_size  output, the current size of `sb` in number of float values."]
    pub fn faiss_IndexFlat_xb(index: *mut FaissIndexFlat, p_xb: *mut *mut f32, p_size: *mut usize);
}
unsafe extern "C" {
    pub fn faiss_IndexFlat_cast(arg1: *mut FaissIndex) -> *mut FaissIndexFlat;
}
unsafe extern "C" {
    pub fn faiss_IndexFlat_free(obj: *mut FaissIndexFlat);
}
unsafe extern "C" {
    #[doc = " compute distance with a subset of vectors\n\n @param index   opaque pointer to index object\n @param x       query vectors, size n * d\n @param labels  indices of the vectors that should be compared\n                for each query vector, size n * k\n @param distances\n                corresponding output distances, size n * k"]
    pub fn faiss_IndexFlat_compute_distance_subset(
        index: *mut FaissIndex,
        n: idx_t,
        x: *const f32,
        k: idx_t,
        distances: *mut f32,
        labels: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexFlatIP = FaissIndex_H;
unsafe extern "C" {
    pub fn faiss_IndexFlatIP_cast(arg1: *mut FaissIndex) -> *mut FaissIndexFlatIP;
}
unsafe extern "C" {
    pub fn faiss_IndexFlatIP_free(obj: *mut FaissIndexFlatIP);
}
unsafe extern "C" {
    #[doc = " Opaque type for IndexFlatIP"]
    pub fn faiss_IndexFlatIP_new(p_index: *mut *mut FaissIndexFlatIP) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexFlatIP_new_with(
        p_index: *mut *mut FaissIndexFlatIP,
        d: idx_t,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexFlatL2 = FaissIndex_H;
unsafe extern "C" {
    pub fn faiss_IndexFlatL2_cast(arg1: *mut FaissIndex) -> *mut FaissIndexFlatL2;
}
unsafe extern "C" {
    pub fn faiss_IndexFlatL2_free(obj: *mut FaissIndexFlatL2);
}
unsafe extern "C" {
    #[doc = " Opaque type for IndexFlatL2"]
    pub fn faiss_IndexFlatL2_new(p_index: *mut *mut FaissIndexFlatL2) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexFlatL2_new_with(
        p_index: *mut *mut FaissIndexFlatL2,
        d: idx_t,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexRefineFlat = FaissIndex_H;
unsafe extern "C" {
    #[doc = " Opaque type for IndexRefineFlat\n\n Index that queries in a base_index (a fast one) and refines the\n results with an exact search, hopefully improving the results."]
    pub fn faiss_IndexRefineFlat_new(
        p_index: *mut *mut FaissIndexRefineFlat,
        base_index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexRefineFlat_free(obj: *mut FaissIndexRefineFlat);
}
unsafe extern "C" {
    pub fn faiss_IndexRefineFlat_cast(arg1: *mut FaissIndex) -> *mut FaissIndexRefineFlat;
}
unsafe extern "C" {
    pub fn faiss_IndexRefineFlat_own_fields(
        arg1: *const FaissIndexRefineFlat,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexRefineFlat_set_own_fields(
        arg1: *mut FaissIndexRefineFlat,
        arg2: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn faiss_IndexRefineFlat_k_factor(arg1: *const FaissIndexRefineFlat) -> f32;
}
unsafe extern "C" {
    pub fn faiss_IndexRefineFlat_set_k_factor(arg1: *mut FaissIndexRefineFlat, arg2: f32);
}
pub type FaissIndexFlat1D = FaissIndex_H;
unsafe extern "C" {
    pub fn faiss_IndexFlat1D_cast(arg1: *mut FaissIndex) -> *mut FaissIndexFlat1D;
}
unsafe extern "C" {
    pub fn faiss_IndexFlat1D_free(obj: *mut FaissIndexFlat1D);
}
unsafe extern "C" {
    #[doc = " Opaque type for IndexFlat1D\n\n optimized version for 1D \"vectors\""]
    pub fn faiss_IndexFlat1D_new(p_index: *mut *mut FaissIndexFlat1D) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexFlat1D_new_with(
        p_index: *mut *mut FaissIndexFlat1D,
        continuous_update: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexFlat1D_update_permutation(
        index: *mut FaissIndexFlat1D,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexIVFFlat = FaissIndex_H;
unsafe extern "C" {
    pub fn faiss_IndexIVFFlat_free(obj: *mut FaissIndexIVFFlat);
}
unsafe extern "C" {
    pub fn faiss_IndexIVFFlat_cast(arg1: *mut FaissIndex) -> *mut FaissIndexIVFFlat;
}
unsafe extern "C" {
    pub fn faiss_IndexIVFFlat_nlist(arg1: *const FaissIndexIVFFlat) -> usize;
}
unsafe extern "C" {
    pub fn faiss_IndexIVFFlat_nprobe(arg1: *const FaissIndexIVFFlat) -> usize;
}
unsafe extern "C" {
    pub fn faiss_IndexIVFFlat_set_nprobe(arg1: *mut FaissIndexIVFFlat, arg2: usize);
}
unsafe extern "C" {
    pub fn faiss_IndexIVFFlat_quantizer(arg1: *const FaissIndexIVFFlat) -> *mut FaissIndex;
}
unsafe extern "C" {
    pub fn faiss_IndexIVFFlat_quantizer_trains_alone(
        arg1: *const FaissIndexIVFFlat,
    ) -> ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn faiss_IndexIVFFlat_own_fields(arg1: *const FaissIndexIVFFlat) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexIVFFlat_set_own_fields(
        arg1: *mut FaissIndexIVFFlat,
        arg2: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " whether object owns the quantizer"]
    pub fn faiss_IndexIVFFlat_new(p_index: *mut *mut FaissIndexIVFFlat) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexIVFFlat_new_with(
        p_index: *mut *mut FaissIndexIVFFlat,
        quantizer: *mut FaissIndex,
        d: usize,
        nlist: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexIVFFlat_new_with_metric(
        p_index: *mut *mut FaissIndexIVFFlat,
        quantizer: *mut FaissIndex,
        d: usize,
        nlist: usize,
        metric: FaissMetricType,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexIVFFlat_add_core(
        index: *mut FaissIndexIVFFlat,
        n: idx_t,
        x: *const f32,
        xids: *const idx_t,
        precomputed_idx: *const i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Update a subset of vectors.\n\n The index must have a direct_map\n\n @param nv     nb of vectors to update\n @param idx    vector indices to update, size nv\n @param v      vectors of new values, size nv*d"]
    pub fn faiss_IndexIVFFlat_update_vectors(
        index: *mut FaissIndexIVFFlat,
        nv: ::std::os::raw::c_int,
        idx: *mut idx_t,
        v: *const f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_RangeSearchResult_nq(arg1: *const FaissRangeSearchResult) -> usize;
}
unsafe extern "C" {
    pub fn faiss_RangeSearchResult_new(
        p_rsr: *mut *mut FaissRangeSearchResult,
        nq: idx_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_RangeSearchResult_new_with(
        p_rsr: *mut *mut FaissRangeSearchResult,
        nq: idx_t,
        alloc_lims: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " called when lims contains the nb of elements result entries\n for each query"]
    pub fn faiss_RangeSearchResult_do_allocation(
        rsr: *mut FaissRangeSearchResult,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_RangeSearchResult_free(obj: *mut FaissRangeSearchResult);
}
unsafe extern "C" {
    pub fn faiss_RangeSearchResult_buffer_size(arg1: *const FaissRangeSearchResult) -> usize;
}
unsafe extern "C" {
    #[doc = " getter for lims: size (nq + 1)"]
    pub fn faiss_RangeSearchResult_lims(rsr: *mut FaissRangeSearchResult, lims: *mut *mut usize);
}
unsafe extern "C" {
    #[doc = " getter for labels and respective distances (not sorted):\n result for query i is labels[lims[i]:lims[i+1]]"]
    pub fn faiss_RangeSearchResult_labels(
        rsr: *mut FaissRangeSearchResult,
        labels: *mut *mut idx_t,
        distances: *mut *mut f32,
    );
}
unsafe extern "C" {
    pub fn faiss_IDSelector_free(obj: *mut FaissIDSelector);
}
unsafe extern "C" {
    #[doc = " Encapsulates a set of ids to remove."]
    pub fn faiss_IDSelector_is_member(
        sel: *const FaissIDSelector,
        id: idx_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIDSelectorRange_H {
    _unused: [u8; 0],
}
pub type FaissIDSelectorRange = FaissIDSelectorRange_H;
unsafe extern "C" {
    pub fn faiss_IDSelectorRange_free(obj: *mut FaissIDSelectorRange);
}
unsafe extern "C" {
    pub fn faiss_IDSelectorRange_imin(arg1: *const FaissIDSelectorRange) -> idx_t;
}
unsafe extern "C" {
    pub fn faiss_IDSelectorRange_imax(arg1: *const FaissIDSelectorRange) -> idx_t;
}
unsafe extern "C" {
    #[doc = " remove ids between [imni, imax)"]
    pub fn faiss_IDSelectorRange_new(
        p_sel: *mut *mut FaissIDSelectorRange,
        imin: idx_t,
        imax: idx_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIDSelectorBatch_H {
    _unused: [u8; 0],
}
pub type FaissIDSelectorBatch = FaissIDSelectorBatch_H;
unsafe extern "C" {
    pub fn faiss_IDSelectorBatch_nbits(arg1: *const FaissIDSelectorBatch) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IDSelectorBatch_mask(arg1: *const FaissIDSelectorBatch) -> idx_t;
}
unsafe extern "C" {
    #[doc = " Remove ids from a set. Repetitions of ids in the indices set\n passed to the constructor does not hurt performance. The hash\n function used for the bloom filter and GCC's implementation of\n unordered_set are just the least significant bits of the id. This\n works fine for random ids or ids in sequences but will produce many\n hash collisions if lsb's are always the same"]
    pub fn faiss_IDSelectorBatch_new(
        p_sel: *mut *mut FaissIDSelectorBatch,
        n: usize,
        indices: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIDSelectorNot_H {
    _unused: [u8; 0],
}
pub type FaissIDSelectorNot = FaissIDSelectorNot_H;
unsafe extern "C" {
    pub fn faiss_IDSelectorNot_new(
        p_sel: *mut *mut FaissIDSelectorNot,
        sel: *const FaissIDSelector,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIDSelectorAnd_H {
    _unused: [u8; 0],
}
pub type FaissIDSelectorAnd = FaissIDSelectorAnd_H;
unsafe extern "C" {
    pub fn faiss_IDSelectorAnd_new(
        p_sel: *mut *mut FaissIDSelectorAnd,
        lhs_sel: *const FaissIDSelector,
        rhs_sel: *const FaissIDSelector,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIDSelectorOr_H {
    _unused: [u8; 0],
}
pub type FaissIDSelectorOr = FaissIDSelectorOr_H;
unsafe extern "C" {
    pub fn faiss_IDSelectorOr_new(
        p_sel: *mut *mut FaissIDSelectorOr,
        lhs_sel: *const FaissIDSelector,
        rhs_sel: *const FaissIDSelector,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIDSelectorXOr_H {
    _unused: [u8; 0],
}
pub type FaissIDSelectorXOr = FaissIDSelectorXOr_H;
unsafe extern "C" {
    pub fn faiss_IDSelectorXOr_new(
        p_sel: *mut *mut FaissIDSelectorXOr,
        lhs_sel: *const FaissIDSelector,
        rhs_sel: *const FaissIDSelector,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissBufferList_H {
    _unused: [u8; 0],
}
pub type FaissBufferList = FaissBufferList_H;
unsafe extern "C" {
    pub fn faiss_BufferList_free(obj: *mut FaissBufferList);
}
unsafe extern "C" {
    pub fn faiss_BufferList_buffer_size(arg1: *const FaissBufferList) -> usize;
}
unsafe extern "C" {
    pub fn faiss_BufferList_wp(arg1: *const FaissBufferList) -> usize;
}
#[doc = " List of temporary buffers used to store results before they are\n  copied to the RangeSearchResult object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissBuffer {
    pub ids: *mut idx_t,
    pub dis: *mut f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FaissBuffer"][::std::mem::size_of::<FaissBuffer>() - 16usize];
    ["Alignment of FaissBuffer"][::std::mem::align_of::<FaissBuffer>() - 8usize];
    ["Offset of field: FaissBuffer::ids"][::std::mem::offset_of!(FaissBuffer, ids) - 0usize];
    ["Offset of field: FaissBuffer::dis"][::std::mem::offset_of!(FaissBuffer, dis) - 8usize];
};
unsafe extern "C" {
    pub fn faiss_BufferList_append_buffer(bl: *mut FaissBufferList) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_BufferList_new(
        p_bl: *mut *mut FaissBufferList,
        buffer_size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_BufferList_add(
        bl: *mut FaissBufferList,
        id: idx_t,
        dis: f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " copy elemnts ofs:ofs+n-1 seen as linear data in the buffers to\n tables dest_ids, dest_dis"]
    pub fn faiss_BufferList_copy_range(
        bl: *mut FaissBufferList,
        ofs: usize,
        n: usize,
        dest_ids: *mut idx_t,
        dest_dis: *mut f32,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissRangeSearchPartialResult_H {
    _unused: [u8; 0],
}
pub type FaissRangeSearchPartialResult = FaissRangeSearchPartialResult_H;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissRangeQueryResult_H {
    _unused: [u8; 0],
}
pub type FaissRangeQueryResult = FaissRangeQueryResult_H;
unsafe extern "C" {
    pub fn faiss_RangeQueryResult_qno(arg1: *const FaissRangeQueryResult) -> idx_t;
}
unsafe extern "C" {
    pub fn faiss_RangeQueryResult_nres(arg1: *const FaissRangeQueryResult) -> usize;
}
unsafe extern "C" {
    pub fn faiss_RangeQueryResult_pres(
        arg1: *const FaissRangeQueryResult,
    ) -> *mut FaissRangeSearchPartialResult;
}
unsafe extern "C" {
    #[doc = " result structure for a single query"]
    pub fn faiss_RangeQueryResult_add(
        qr: *mut FaissRangeQueryResult,
        dis: f32,
        id: idx_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_RangeSearchPartialResult_res(
        arg1: *const FaissRangeSearchPartialResult,
    ) -> *mut FaissRangeSearchResult;
}
unsafe extern "C" {
    pub fn faiss_RangeSearchPartialResult_new(
        p_res: *mut *mut FaissRangeSearchPartialResult,
        res_in: *mut FaissRangeSearchResult,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_RangeSearchPartialResult_finalize(
        res: *mut FaissRangeSearchPartialResult,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " called by range_search before do_allocation"]
    pub fn faiss_RangeSearchPartialResult_set_lims(
        res: *mut FaissRangeSearchPartialResult,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_RangeSearchPartialResult_new_result(
        res: *mut FaissRangeSearchPartialResult,
        qno: idx_t,
        qr: *mut *mut FaissRangeQueryResult,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissDistanceComputer_H {
    _unused: [u8; 0],
}
pub type FaissDistanceComputer = FaissDistanceComputer_H;
unsafe extern "C" {
    #[doc = " called before computing distances"]
    pub fn faiss_DistanceComputer_set_query(
        dc: *mut FaissDistanceComputer,
        x: *const f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Compute distance of vector i to current query.\n This function corresponds to the function call operator:\n DistanceComputer::operator()"]
    pub fn faiss_DistanceComputer_vector_to_query_dis(
        dc: *mut FaissDistanceComputer,
        i: idx_t,
        qd: *mut f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " compute distance between two stored vectors"]
    pub fn faiss_DistanceComputer_symmetric_dis(
        dc: *mut FaissDistanceComputer,
        i: idx_t,
        j: idx_t,
        vd: *mut f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_DistanceComputer_free(obj: *mut FaissDistanceComputer);
}
pub type FaissSearchParametersIVF = FaissSearchParameters_H;
unsafe extern "C" {
    pub fn faiss_SearchParametersIVF_free(obj: *mut FaissSearchParametersIVF);
}
unsafe extern "C" {
    pub fn faiss_SearchParametersIVF_cast(
        arg1: *mut FaissSearchParameters,
    ) -> *mut FaissSearchParametersIVF;
}
unsafe extern "C" {
    pub fn faiss_SearchParametersIVF_new(
        p_sp: *mut *mut FaissSearchParametersIVF,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_SearchParametersIVF_new_with(
        p_sp: *mut *mut FaissSearchParametersIVF,
        sel: *mut FaissIDSelector,
        nprobe: usize,
        max_codes: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_SearchParametersIVF_sel(
        arg1: *const FaissSearchParametersIVF,
    ) -> *const FaissIDSelector;
}
unsafe extern "C" {
    pub fn faiss_SearchParametersIVF_nprobe(arg1: *const FaissSearchParametersIVF) -> usize;
}
unsafe extern "C" {
    pub fn faiss_SearchParametersIVF_set_nprobe(arg1: *mut FaissSearchParametersIVF, arg2: usize);
}
unsafe extern "C" {
    pub fn faiss_SearchParametersIVF_max_codes(arg1: *const FaissSearchParametersIVF) -> usize;
}
unsafe extern "C" {
    pub fn faiss_SearchParametersIVF_set_max_codes(
        arg1: *mut FaissSearchParametersIVF,
        arg2: usize,
    );
}
pub type FaissIndexIVF = FaissIndex_H;
unsafe extern "C" {
    pub fn faiss_IndexIVF_free(obj: *mut FaissIndexIVF);
}
unsafe extern "C" {
    pub fn faiss_IndexIVF_cast(arg1: *mut FaissIndex) -> *mut FaissIndexIVF;
}
unsafe extern "C" {
    pub fn faiss_IndexIVF_nlist(arg1: *const FaissIndexIVF) -> usize;
}
unsafe extern "C" {
    pub fn faiss_IndexIVF_nprobe(arg1: *const FaissIndexIVF) -> usize;
}
unsafe extern "C" {
    pub fn faiss_IndexIVF_set_nprobe(arg1: *mut FaissIndexIVF, arg2: usize);
}
unsafe extern "C" {
    pub fn faiss_IndexIVF_quantizer(arg1: *const FaissIndexIVF) -> *mut FaissIndex;
}
unsafe extern "C" {
    pub fn faiss_IndexIVF_quantizer_trains_alone(
        arg1: *const FaissIndexIVF,
    ) -> ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn faiss_IndexIVF_own_fields(arg1: *const FaissIndexIVF) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexIVF_set_own_fields(arg1: *mut FaissIndexIVF, arg2: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " moves the entries from another dataset to self. On output,\n other is empty. add_id is added to all moved ids (for\n sequential ids, this would be this->ntotal"]
    pub fn faiss_IndexIVF_merge_from(
        index: *mut FaissIndexIVF,
        other: *mut FaissIndexIVF,
        add_id: idx_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " copy a subset of the entries index to the other index\n\n if subset_type == 0: copies ids in [a1, a2)\n if subset_type == 1: copies ids if id % a1 == a2\n if subset_type == 2: copies inverted lists such that a1\n                      elements are left before and a2 elements are after"]
    pub fn faiss_IndexIVF_copy_subset_to(
        index: *const FaissIndexIVF,
        other: *mut FaissIndexIVF,
        subset_type: ::std::os::raw::c_int,
        a1: idx_t,
        a2: idx_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " search a set of vectors, that are pre-quantized by the IVF\n  quantizer. Fill in the corresponding heaps with the query\n  results. search() calls this.\n\n @param n      nb of vectors to query\n @param x      query vectors, size nx * d\n @param assign coarse quantization indices, size nx * nprobe\n @param centroid_dis\n               distances to coarse centroids, size nx * nprobe\n @param distance\n               output distances, size n * k\n @param labels output labels, size n * k\n @param store_pairs store inv list index + inv list offset\n                     instead in upper/lower 32 bit of result,\n                     instead of ids (used for reranking)."]
    pub fn faiss_IndexIVF_search_preassigned(
        index: *const FaissIndexIVF,
        n: idx_t,
        x: *const f32,
        k: idx_t,
        assign: *const idx_t,
        centroid_dis: *const f32,
        distances: *mut f32,
        labels: *mut idx_t,
        store_pairs: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexIVF_get_list_size(index: *const FaissIndexIVF, list_no: usize) -> usize;
}
unsafe extern "C" {
    #[doc = " initialize a direct map\n\n @param new_maintain_direct_map    if true, create a direct map,\n                                   else clear it"]
    pub fn faiss_IndexIVF_make_direct_map(
        index: *mut FaissIndexIVF,
        new_maintain_direct_map: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check the inverted lists' imbalance factor.\n\n 1= perfectly balanced, >1: imbalanced"]
    pub fn faiss_IndexIVF_imbalance_factor(index: *const FaissIndexIVF) -> f64;
}
unsafe extern "C" {
    #[doc = " display some stats about the inverted lists of the index"]
    pub fn faiss_IndexIVF_print_stats(index: *const FaissIndexIVF);
}
unsafe extern "C" {
    #[doc = " Get the IDs in an inverted list. IDs are written to `invlist`, which must be\n large enough\n to accommodate the full list.\n\n @param list_no the list ID\n @param invlist output pointer to a slice of memory, at least as long as the\n list's size\n @see faiss_IndexIVF_get_list_size(size_t)"]
    pub fn faiss_IndexIVF_invlists_get_ids(
        index: *const FaissIndexIVF,
        list_no: usize,
        invlist: *mut idx_t,
    );
}
unsafe extern "C" {
    pub fn faiss_IndexIVF_train_encoder(
        index: *mut FaissIndexIVF,
        n: idx_t,
        x: *const f32,
        assign: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIndexIVFStats {
    pub nq: usize,
    pub nlist: usize,
    pub ndis: usize,
    pub nheap_updates: usize,
    pub quantization_time: f64,
    pub search_time: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FaissIndexIVFStats"][::std::mem::size_of::<FaissIndexIVFStats>() - 48usize];
    ["Alignment of FaissIndexIVFStats"][::std::mem::align_of::<FaissIndexIVFStats>() - 8usize];
    ["Offset of field: FaissIndexIVFStats::nq"]
        [::std::mem::offset_of!(FaissIndexIVFStats, nq) - 0usize];
    ["Offset of field: FaissIndexIVFStats::nlist"]
        [::std::mem::offset_of!(FaissIndexIVFStats, nlist) - 8usize];
    ["Offset of field: FaissIndexIVFStats::ndis"]
        [::std::mem::offset_of!(FaissIndexIVFStats, ndis) - 16usize];
    ["Offset of field: FaissIndexIVFStats::nheap_updates"]
        [::std::mem::offset_of!(FaissIndexIVFStats, nheap_updates) - 24usize];
    ["Offset of field: FaissIndexIVFStats::quantization_time"]
        [::std::mem::offset_of!(FaissIndexIVFStats, quantization_time) - 32usize];
    ["Offset of field: FaissIndexIVFStats::search_time"]
        [::std::mem::offset_of!(FaissIndexIVFStats, search_time) - 40usize];
};
unsafe extern "C" {
    pub fn faiss_IndexIVFStats_reset(stats: *mut FaissIndexIVFStats);
}
unsafe extern "C" {
    #[doc = " global var that collects all statists"]
    pub fn faiss_get_indexIVF_stats() -> *mut FaissIndexIVFStats;
}
pub type FaissIndexLSH = FaissIndex_H;
unsafe extern "C" {
    pub fn faiss_IndexLSH_free(obj: *mut FaissIndexLSH);
}
unsafe extern "C" {
    pub fn faiss_IndexLSH_cast(arg1: *mut FaissIndex) -> *mut FaissIndexLSH;
}
unsafe extern "C" {
    pub fn faiss_IndexLSH_nbits(arg1: *const FaissIndexLSH) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexLSH_code_size(arg1: *const FaissIndexLSH) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexLSH_rotate_data(arg1: *const FaissIndexLSH) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexLSH_train_thresholds(arg1: *const FaissIndexLSH) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " The sign of each vector component is put in a binary signature"]
    pub fn faiss_IndexLSH_new(
        p_index: *mut *mut FaissIndexLSH,
        d: idx_t,
        nbits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexLSH_new_with_options(
        p_index: *mut *mut FaissIndexLSH,
        d: idx_t,
        nbits: ::std::os::raw::c_int,
        rotate_data: ::std::os::raw::c_int,
        train_thresholds: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissVectorTransform_H {
    _unused: [u8; 0],
}
pub type FaissVectorTransform = FaissVectorTransform_H;
unsafe extern "C" {
    pub fn faiss_VectorTransform_free(obj: *mut FaissVectorTransform);
}
unsafe extern "C" {
    pub fn faiss_VectorTransform_is_trained(
        arg1: *const FaissVectorTransform,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_VectorTransform_d_in(arg1: *const FaissVectorTransform) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_VectorTransform_d_out(arg1: *const FaissVectorTransform) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Perform training on a representative set of vectors\n\n @param vt     opaque pointer to VectorTransform object\n @param n      nb of training vectors\n @param x      training vectors, size n * d"]
    pub fn faiss_VectorTransform_train(
        vt: *mut FaissVectorTransform,
        n: idx_t,
        x: *const f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " apply the random rotation, return new allocated matrix\n @param     x size n * d_in\n @return    size n * d_out"]
    pub fn faiss_VectorTransform_apply(
        vt: *const FaissVectorTransform,
        n: idx_t,
        x: *const f32,
    ) -> *mut f32;
}
unsafe extern "C" {
    #[doc = " apply transformation and result is pre-allocated\n @param     x size n * d_in\n @param     xt size n * d_out"]
    pub fn faiss_VectorTransform_apply_noalloc(
        vt: *const FaissVectorTransform,
        n: idx_t,
        x: *const f32,
        xt: *mut f32,
    );
}
unsafe extern "C" {
    #[doc = " reverse transformation. May not be implemented or may return\n approximate result"]
    pub fn faiss_VectorTransform_reverse_transform(
        vt: *const FaissVectorTransform,
        n: idx_t,
        xt: *const f32,
        x: *mut f32,
    );
}
pub type FaissLinearTransform = FaissVectorTransform_H;
unsafe extern "C" {
    pub fn faiss_LinearTransform_free(obj: *mut FaissLinearTransform);
}
unsafe extern "C" {
    #[doc = " compute x = A^T * (x - b)\n is reverse transform if A has orthonormal lines"]
    pub fn faiss_LinearTransform_transform_transpose(
        vt: *const FaissLinearTransform,
        n: idx_t,
        y: *const f32,
        x: *mut f32,
    );
}
unsafe extern "C" {
    #[doc = " compute A^T * A to set the is_orthonormal flag"]
    pub fn faiss_LinearTransform_set_is_orthonormal(vt: *mut FaissLinearTransform);
}
unsafe extern "C" {
    pub fn faiss_LinearTransform_have_bias(
        arg1: *const FaissLinearTransform,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_LinearTransform_is_orthonormal(
        arg1: *const FaissLinearTransform,
    ) -> ::std::os::raw::c_int;
}
pub type FaissRandomRotationMatrix = FaissVectorTransform_H;
unsafe extern "C" {
    pub fn faiss_RandomRotationMatrix_free(obj: *mut FaissRandomRotationMatrix);
}
unsafe extern "C" {
    #[doc = " Getter for is_orthonormal"]
    pub fn faiss_RandomRotationMatrix_new_with(
        p_vt: *mut *mut FaissRandomRotationMatrix,
        d_in: ::std::os::raw::c_int,
        d_out: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type FaissPCAMatrix = FaissVectorTransform_H;
unsafe extern "C" {
    pub fn faiss_PCAMatrix_free(obj: *mut FaissPCAMatrix);
}
unsafe extern "C" {
    pub fn faiss_PCAMatrix_new_with(
        p_vt: *mut *mut FaissPCAMatrix,
        d_in: ::std::os::raw::c_int,
        d_out: ::std::os::raw::c_int,
        eigen_power: f32,
        random_rotation: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_PCAMatrix_eigen_power(arg1: *const FaissPCAMatrix) -> f32;
}
unsafe extern "C" {
    pub fn faiss_PCAMatrix_random_rotation(arg1: *const FaissPCAMatrix) -> ::std::os::raw::c_int;
}
pub type FaissITQMatrix = FaissVectorTransform_H;
unsafe extern "C" {
    pub fn faiss_ITQMatrix_free(obj: *mut FaissITQMatrix);
}
unsafe extern "C" {
    #[doc = " Getter for random_rotation"]
    pub fn faiss_ITQMatrix_new_with(
        p_vt: *mut *mut FaissITQMatrix,
        d: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type FaissITQTransform = FaissVectorTransform_H;
unsafe extern "C" {
    pub fn faiss_ITQTransform_free(obj: *mut FaissITQTransform);
}
unsafe extern "C" {
    pub fn faiss_ITQTransform_new_with(
        p_vt: *mut *mut FaissITQTransform,
        d_in: ::std::os::raw::c_int,
        d_out: ::std::os::raw::c_int,
        do_pca: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_ITQTransform_do_pca(arg1: *const FaissITQTransform) -> ::std::os::raw::c_int;
}
pub type FaissOPQMatrix = FaissVectorTransform_H;
unsafe extern "C" {
    pub fn faiss_OPQMatrix_free(obj: *mut FaissOPQMatrix);
}
unsafe extern "C" {
    #[doc = " Getter for do_pca"]
    pub fn faiss_OPQMatrix_new_with(
        p_vt: *mut *mut FaissOPQMatrix,
        d: ::std::os::raw::c_int,
        M: ::std::os::raw::c_int,
        d2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_OPQMatrix_verbose(arg1: *const FaissOPQMatrix) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_OPQMatrix_set_verbose(arg1: *mut FaissOPQMatrix, arg2: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn faiss_OPQMatrix_niter(arg1: *const FaissOPQMatrix) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_OPQMatrix_set_niter(arg1: *mut FaissOPQMatrix, arg2: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn faiss_OPQMatrix_niter_pq(arg1: *const FaissOPQMatrix) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_OPQMatrix_set_niter_pq(arg1: *mut FaissOPQMatrix, arg2: ::std::os::raw::c_int);
}
pub type FaissRemapDimensionsTransform = FaissVectorTransform_H;
unsafe extern "C" {
    pub fn faiss_RemapDimensionsTransform_free(obj: *mut FaissRemapDimensionsTransform);
}
unsafe extern "C" {
    pub fn faiss_RemapDimensionsTransform_new_with(
        p_vt: *mut *mut FaissRemapDimensionsTransform,
        d_in: ::std::os::raw::c_int,
        d_out: ::std::os::raw::c_int,
        uniform: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type FaissNormalizationTransform = FaissVectorTransform_H;
unsafe extern "C" {
    pub fn faiss_NormalizationTransform_free(obj: *mut FaissNormalizationTransform);
}
unsafe extern "C" {
    pub fn faiss_NormalizationTransform_new_with(
        p_vt: *mut *mut FaissNormalizationTransform,
        d: ::std::os::raw::c_int,
        norm: f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_NormalizationTransform_norm(arg1: *const FaissNormalizationTransform) -> f32;
}
pub type FaissCenteringTransform = FaissVectorTransform_H;
unsafe extern "C" {
    pub fn faiss_CenteringTransform_free(obj: *mut FaissCenteringTransform);
}
unsafe extern "C" {
    pub fn faiss_CenteringTransform_new_with(
        p_vt: *mut *mut FaissCenteringTransform,
        d: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexPreTransform = FaissIndex_H;
unsafe extern "C" {
    pub fn faiss_IndexPreTransform_free(obj: *mut FaissIndexPreTransform);
}
unsafe extern "C" {
    pub fn faiss_IndexPreTransform_cast(arg1: *mut FaissIndex) -> *mut FaissIndexPreTransform;
}
unsafe extern "C" {
    pub fn faiss_IndexPreTransform_index(arg1: *const FaissIndexPreTransform) -> *mut FaissIndex;
}
unsafe extern "C" {
    pub fn faiss_IndexPreTransform_own_fields(
        arg1: *const FaissIndexPreTransform,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexPreTransform_set_own_fields(
        arg1: *mut FaissIndexPreTransform,
        arg2: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Index that applies a LinearTransform transform on vectors before\n  handing them over to a sub-index"]
    pub fn faiss_IndexPreTransform_new(
        p_index: *mut *mut FaissIndexPreTransform,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexPreTransform_new_with(
        p_index: *mut *mut FaissIndexPreTransform,
        index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexPreTransform_new_with_transform(
        p_index: *mut *mut FaissIndexPreTransform,
        ltrans: *mut FaissVectorTransform,
        index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexPreTransform_prepend_transform(
        index: *mut FaissIndexPreTransform,
        ltrans: *mut FaissVectorTransform,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexReplicas = FaissIndex_H;
unsafe extern "C" {
    pub fn faiss_IndexReplicas_free(obj: *mut FaissIndexReplicas);
}
unsafe extern "C" {
    pub fn faiss_IndexReplicas_own_fields(arg1: *const FaissIndexReplicas)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexReplicas_set_own_fields(
        arg1: *mut FaissIndexReplicas,
        arg2: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Index that concatenates the results from several sub-indexes"]
    pub fn faiss_IndexReplicas_new(
        p_index: *mut *mut FaissIndexReplicas,
        d: idx_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexReplicas_new_with_options(
        p_index: *mut *mut FaissIndexReplicas,
        d: idx_t,
        threaded: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexReplicas_add_replica(
        index: *mut FaissIndexReplicas,
        replica: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexReplicas_remove_replica(
        index: *mut FaissIndexReplicas,
        replica: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexReplicas_at(
        index: *mut FaissIndexReplicas,
        i: ::std::os::raw::c_int,
    ) -> *mut FaissIndex;
}
#[doc = "< 8 bits per component"]
pub const FaissQuantizerType_QT_8bit: FaissQuantizerType = 0;
#[doc = "< 4 bits per component"]
pub const FaissQuantizerType_QT_4bit: FaissQuantizerType = 1;
#[doc = "< same, shared range for all dimensions"]
pub const FaissQuantizerType_QT_8bit_uniform: FaissQuantizerType = 2;
pub const FaissQuantizerType_QT_4bit_uniform: FaissQuantizerType = 3;
pub const FaissQuantizerType_QT_fp16: FaissQuantizerType = 4;
#[doc = "< fast indexing of uint8s"]
pub const FaissQuantizerType_QT_8bit_direct: FaissQuantizerType = 5;
#[doc = "< 6 bits per component"]
pub const FaissQuantizerType_QT_6bit: FaissQuantizerType = 6;
pub const FaissQuantizerType_QT_bf16: FaissQuantizerType = 7;
#[doc = "< fast indexing of signed int8s ranging from [-128\n< to 127]"]
pub const FaissQuantizerType_QT_8bit_direct_signed: FaissQuantizerType = 8;
pub type FaissQuantizerType = ::std::os::raw::c_uint;
pub type FaissIndexScalarQuantizer = FaissIndex_H;
unsafe extern "C" {
    #[doc = " Opaque type for IndexScalarQuantizer"]
    pub fn faiss_IndexScalarQuantizer_new(
        p_index: *mut *mut FaissIndexScalarQuantizer,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexScalarQuantizer_new_with(
        p_index: *mut *mut FaissIndexScalarQuantizer,
        d: idx_t,
        qt: FaissQuantizerType,
        metric: FaissMetricType,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexScalarQuantizer_cast(arg1: *mut FaissIndex)
        -> *mut FaissIndexScalarQuantizer;
}
unsafe extern "C" {
    pub fn faiss_IndexScalarQuantizer_free(obj: *mut FaissIndexScalarQuantizer);
}
pub type FaissIndexIVFScalarQuantizer = FaissIndex_H;
unsafe extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_cast(
        arg1: *mut FaissIndex,
    ) -> *mut FaissIndexIVFScalarQuantizer;
}
unsafe extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_free(obj: *mut FaissIndexIVFScalarQuantizer);
}
unsafe extern "C" {
    #[doc = " Opaque type for IndexIVFScalarQuantizer"]
    pub fn faiss_IndexIVFScalarQuantizer_new(
        p_index: *mut *mut FaissIndexIVFScalarQuantizer,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_new_with(
        p_index: *mut *mut FaissIndexIVFScalarQuantizer,
        quantizer: *mut FaissIndex,
        d: idx_t,
        nlist: usize,
        qt: FaissQuantizerType,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_new_with_metric(
        p_index: *mut *mut FaissIndexIVFScalarQuantizer,
        quantizer: *mut FaissIndex,
        d: usize,
        nlist: usize,
        qt: FaissQuantizerType,
        metric: FaissMetricType,
        encode_residual: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_nlist(arg1: *const FaissIndexIVFScalarQuantizer) -> usize;
}
unsafe extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_nprobe(arg1: *const FaissIndexIVFScalarQuantizer)
        -> usize;
}
unsafe extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_set_nprobe(
        arg1: *mut FaissIndexIVFScalarQuantizer,
        arg2: usize,
    );
}
unsafe extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_quantizer(
        arg1: *const FaissIndexIVFScalarQuantizer,
    ) -> *mut FaissIndex;
}
unsafe extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_own_fields(
        arg1: *const FaissIndexIVFScalarQuantizer,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_set_own_fields(
        arg1: *mut FaissIndexIVFScalarQuantizer,
        arg2: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " whether object owns the quantizer"]
    pub fn faiss_IndexIVFScalarQuantizer_add_core(
        index: *mut FaissIndexIVFScalarQuantizer,
        n: idx_t,
        x: *const f32,
        xids: *const idx_t,
        precomputed_idx: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexShards = FaissIndex_H;
unsafe extern "C" {
    pub fn faiss_IndexShards_free(obj: *mut FaissIndexShards);
}
unsafe extern "C" {
    pub fn faiss_IndexShards_own_fields(arg1: *const FaissIndexShards) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexShards_set_own_fields(
        arg1: *mut FaissIndexShards,
        arg2: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn faiss_IndexShards_successive_ids(arg1: *const FaissIndexShards)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexShards_set_successive_ids(
        arg1: *mut FaissIndexShards,
        arg2: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Index that concatenates the results from several sub-indexes"]
    pub fn faiss_IndexShards_new(
        p_index: *mut *mut FaissIndexShards,
        d: idx_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexShards_new_with_options(
        p_index: *mut *mut FaissIndexShards,
        d: idx_t,
        threaded: ::std::os::raw::c_int,
        successive_ids: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexShards_add_shard(
        index: *mut FaissIndexShards,
        shard: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexShards_remove_shard(
        index: *mut FaissIndexShards,
        shard: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexShards_at(
        index: *mut FaissIndexShards,
        i: ::std::os::raw::c_int,
    ) -> *mut FaissIndex;
}
pub type FaissIndexIDMap = FaissIndex_H;
unsafe extern "C" {
    pub fn faiss_IndexIDMap_own_fields(arg1: *const FaissIndexIDMap) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexIDMap_set_own_fields(arg1: *mut FaissIndexIDMap, arg2: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Index that translates search results to ids"]
    pub fn faiss_IndexIDMap_new(
        p_index: *mut *mut FaissIndexIDMap,
        index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexIDMap_cast(arg1: *mut FaissIndex) -> *mut FaissIndexIDMap;
}
unsafe extern "C" {
    #[doc = " get a pointer to the index map's internal ID vector (the `id_map` field).\n The outputs of this function become invalid after any operation that can\n modify the index.\n\n @param index   opaque pointer to index object\n @param p_id_map    output, the pointer to the beginning of `id_map`.\n @param p_size  output, the current length of `id_map`."]
    pub fn faiss_IndexIDMap_id_map(
        index: *mut FaissIndexIDMap,
        p_id_map: *mut *mut idx_t,
        p_size: *mut usize,
    );
}
unsafe extern "C" {
    #[doc = " get a pointer to the sub-index (the `index` field).\n The outputs of this function become invalid after any operation that can\n modify the index.\n\n @param index   opaque pointer to index object"]
    pub fn faiss_IndexIDMap_sub_index(index: *mut FaissIndexIDMap) -> *mut FaissIndex;
}
pub type FaissIndexIDMap2 = FaissIndex_H;
unsafe extern "C" {
    pub fn faiss_IndexIDMap2_own_fields(arg1: *const FaissIndexIDMap2) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexIDMap2_set_own_fields(
        arg1: *mut FaissIndexIDMap2,
        arg2: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " same as IndexIDMap but also provides an efficient reconstruction\nimplementation via a 2-way index"]
    pub fn faiss_IndexIDMap2_new(
        p_index: *mut *mut FaissIndexIDMap2,
        index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " make the rev_map from scratch"]
    pub fn faiss_IndexIDMap2_construct_rev_map(
        index: *mut FaissIndexIDMap2,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_IndexIDMap2_cast(arg1: *mut FaissIndex) -> *mut FaissIndexIDMap2;
}
unsafe extern "C" {
    #[doc = " get a pointer to the index map's internal ID vector (the `id_map` field).\n The outputs of this function become invalid after any operation that can\n modify the index.\n\n @param index   opaque pointer to index object\n @param p_id_map    output, the pointer to the beginning of `id_map`.\n @param p_size  output, the current length of `id_map`."]
    pub fn faiss_IndexIDMap2_id_map(
        index: *mut FaissIndexIDMap2,
        p_id_map: *mut *mut idx_t,
        p_size: *mut usize,
    );
}
unsafe extern "C" {
    #[doc = " get a pointer to the sub-index (the `index` field).\n The outputs of this function become invalid after any operation that can\n modify the index.\n\n @param index   opaque pointer to index object"]
    pub fn faiss_IndexIDMap2_sub_index(index: *mut FaissIndexIDMap2) -> *mut FaissIndex;
}
pub type FILE = __BindgenOpaqueArray<u64, 27usize>;
unsafe extern "C" {
    #[doc = " Clone an index. This is equivalent to `faiss::clone_index`"]
    pub fn faiss_clone_index(
        arg1: *const FaissIndex,
        p_out: *mut *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Clone a binary index. This is equivalent to `faiss::clone_index_binary`"]
    pub fn faiss_clone_index_binary(
        arg1: *const FaissIndexBinary,
        p_out: *mut *mut FaissIndexBinary,
    ) -> ::std::os::raw::c_int;
}
#[doc = " No error"]
pub const FaissErrorCode_OK: FaissErrorCode = 0;
#[doc = " Any exception other than Faiss or standard C++ library exceptions"]
pub const FaissErrorCode_UNKNOWN_EXCEPT: FaissErrorCode = -1;
#[doc = " Faiss library exception"]
pub const FaissErrorCode_FAISS_EXCEPT: FaissErrorCode = -2;
#[doc = " Standard C++ library exception"]
pub const FaissErrorCode_STD_EXCEPT: FaissErrorCode = -4;
#[doc = " An error code which depends on the exception thrown from the previous\n operation. See `faiss_get_last_error` to retrieve the error message."]
pub type FaissErrorCode = ::std::os::raw::c_int;
unsafe extern "C" {
    #[doc = " Get the error message of the last failed operation performed by Faiss.\n The given pointer is only invalid until another Faiss function is\n called."]
    pub fn faiss_get_last_error() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Build an index with the sequence of processing steps described in\n  the string."]
    pub fn faiss_index_factory(
        p_index: *mut *mut FaissIndex,
        d: ::std::os::raw::c_int,
        description: *const ::std::os::raw::c_char,
        metric: FaissMetricType,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Build a binary index with the sequence of processing steps described in\n  the string."]
    pub fn faiss_index_binary_factory(
        p_index: *mut *mut FaissIndexBinary,
        d: ::std::os::raw::c_int,
        description: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Write index to a file.\n This is equivalent to `faiss::write_index` when a file descriptor is\n provided."]
    pub fn faiss_write_index(idx: *const FaissIndex, f: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Write index to a file.\n This is equivalent to `faiss::write_index` when a file path is provided."]
    pub fn faiss_write_index_fname(
        idx: *const FaissIndex,
        fname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Read index from a file.\n This is equivalent to `faiss:read_index` when a file descriptor is given."]
    pub fn faiss_read_index(
        f: *mut FILE,
        io_flags: ::std::os::raw::c_int,
        p_out: *mut *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Read index from a file.\n This is equivalent to `faiss:read_index` when a file path is given."]
    pub fn faiss_read_index_fname(
        fname: *const ::std::os::raw::c_char,
        io_flags: ::std::os::raw::c_int,
        p_out: *mut *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Write index to a file.\n This is equivalent to `faiss::write_index_binary` when a file descriptor is\n provided."]
    pub fn faiss_write_index_binary(
        idx: *const FaissIndexBinary,
        f: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Write index to a file.\n This is equivalent to `faiss::write_index_binary` when a file path is\n provided."]
    pub fn faiss_write_index_binary_fname(
        idx: *const FaissIndexBinary,
        fname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Read index from a file.\n This is equivalent to `faiss:read_index_binary` when a file descriptor is\n given."]
    pub fn faiss_read_index_binary(
        f: *mut FILE,
        io_flags: ::std::os::raw::c_int,
        p_out: *mut *mut FaissIndexBinary,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Read index from a file.\n This is equivalent to `faiss:read_index_binary` when a file path is given."]
    pub fn faiss_read_index_binary_fname(
        fname: *const ::std::os::raw::c_char,
        io_flags: ::std::os::raw::c_int,
        p_out: *mut *mut FaissIndexBinary,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Read vector transform from a file.\n This is equivalent to `faiss:read_VectorTransform` when a file path is given."]
    pub fn faiss_read_VectorTransform_fname(
        fname: *const ::std::os::raw::c_char,
        p_out: *mut *mut FaissVectorTransform,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Compute pairwise distances between sets of vectors"]
    pub fn faiss_pairwise_L2sqr(
        d: i64,
        nq: i64,
        xq: *const f32,
        nb: i64,
        xb: *const f32,
        dis: *mut f32,
        ldq: i64,
        ldb: i64,
        ldd: i64,
    );
}
unsafe extern "C" {
    #[doc = " Compute pairwise distances between sets of vectors\n arguments from \"faiss_pairwise_L2sqr\"\n ldq equal -1 by default\n ldb equal -1 by default\n ldd equal -1 by default"]
    pub fn faiss_pairwise_L2sqr_with_defaults(
        d: i64,
        nq: i64,
        xq: *const f32,
        nb: i64,
        xb: *const f32,
        dis: *mut f32,
    );
}
unsafe extern "C" {
    #[doc = " compute the inner product between nx vectors x and one y"]
    pub fn faiss_fvec_inner_products_ny(
        ip: *mut f32,
        x: *const f32,
        y: *const f32,
        d: usize,
        ny: usize,
    );
}
unsafe extern "C" {
    #[doc = " compute ny square L2 distance between x and a set of contiguous y vectors"]
    pub fn faiss_fvec_L2sqr_ny(dis: *mut f32, x: *const f32, y: *const f32, d: usize, ny: usize);
}
unsafe extern "C" {
    #[doc = " squared norm of a vector"]
    pub fn faiss_fvec_norm_L2sqr(x: *const f32, d: usize) -> f32;
}
unsafe extern "C" {
    #[doc = " compute the L2 norms for a set of vectors"]
    pub fn faiss_fvec_norms_L2(norms: *mut f32, x: *const f32, d: usize, nx: usize);
}
unsafe extern "C" {
    #[doc = " same as fvec_norms_L2, but computes squared norms"]
    pub fn faiss_fvec_norms_L2sqr(norms: *mut f32, x: *const f32, d: usize, nx: usize);
}
unsafe extern "C" {
    #[doc = " L2-renormalize a set of vector. Nothing done if the vector is 0-normed"]
    pub fn faiss_fvec_renorm_L2(d: usize, nx: usize, x: *mut f32);
}
unsafe extern "C" {
    #[doc = " Setter of threshold value on nx above which we switch to BLAS to compute\n distances"]
    pub fn faiss_set_distance_compute_blas_threshold(value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Getter of threshold value on nx above which we switch to BLAS to compute\n distances"]
    pub fn faiss_get_distance_compute_blas_threshold() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Setter of block sizes value for BLAS distance computations"]
    pub fn faiss_set_distance_compute_blas_query_bs(value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Getter of block sizes value for BLAS distance computations"]
    pub fn faiss_get_distance_compute_blas_query_bs() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Setter of block sizes value for BLAS distance computations"]
    pub fn faiss_set_distance_compute_blas_database_bs(value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Getter of block sizes value for BLAS distance computations"]
    pub fn faiss_get_distance_compute_blas_database_bs() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Setter of number of results we switch to a reservoir to collect results\n rather than a heap"]
    pub fn faiss_set_distance_compute_min_k_reservoir(value: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Getter of number of results we switch to a reservoir to collect results\n rather than a heap"]
    pub fn faiss_get_distance_compute_min_k_reservoir() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_get_version() -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstream_st {
    _unused: [u8; 0],
}
#[doc = " CUDA stream"]
pub type cudaStream_t = *mut CUstream_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cublasContext {
    _unused: [u8; 0],
}
pub type cublasHandle_t = *mut cublasContext;
unsafe extern "C" {
    #[doc = " Returns the number of available GPU devices"]
    pub fn faiss_get_num_gpus(p_output: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Starts the CUDA profiler (exposed via SWIG)"]
    pub fn faiss_gpu_profiler_start() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Stops the CUDA profiler (exposed via SWIG)"]
    pub fn faiss_gpu_profiler_stop() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Synchronizes the CPU against all devices (equivalent to\n cudaDeviceSynchronize for each device)"]
    pub fn faiss_gpu_sync_all_devices() -> ::std::os::raw::c_int;
}
#[doc = " The user indices are only stored on the CPU; the GPU returns\n (inverted list, offset) to the CPU which is then translated to\n the real user index."]
pub const FaissIndicesOptions_INDICES_CPU: FaissIndicesOptions = 0;
#[doc = " The indices are not stored at all, on either the CPU or\n GPU. Only (inverted list, offset) is returned to the user as the\n index."]
pub const FaissIndicesOptions_INDICES_IVF: FaissIndicesOptions = 1;
#[doc = " Indices are stored as 32 bit integers on the GPU, but returned\n as 64 bit integers"]
pub const FaissIndicesOptions_INDICES_32_BIT: FaissIndicesOptions = 2;
#[doc = " Indices are stored as 64 bit integers on the GPU"]
pub const FaissIndicesOptions_INDICES_64_BIT: FaissIndicesOptions = 3;
#[doc = " How user vector index data is stored on the GPU"]
pub type FaissIndicesOptions = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissGpuClonerOptions_H {
    _unused: [u8; 0],
}
pub type FaissGpuClonerOptions = FaissGpuClonerOptions_H;
unsafe extern "C" {
    pub fn faiss_GpuClonerOptions_free(obj: *mut FaissGpuClonerOptions);
}
unsafe extern "C" {
    #[doc = " Default constructor for GpuClonerOptions"]
    pub fn faiss_GpuClonerOptions_new(
        arg1: *mut *mut FaissGpuClonerOptions,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_GpuClonerOptions_indicesOptions(
        arg1: *const FaissGpuClonerOptions,
    ) -> FaissIndicesOptions;
}
unsafe extern "C" {
    pub fn faiss_GpuClonerOptions_set_indicesOptions(
        arg1: *mut FaissGpuClonerOptions,
        arg2: FaissIndicesOptions,
    );
}
unsafe extern "C" {
    pub fn faiss_GpuClonerOptions_useFloat16CoarseQuantizer(
        arg1: *const FaissGpuClonerOptions,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_GpuClonerOptions_set_useFloat16CoarseQuantizer(
        arg1: *mut FaissGpuClonerOptions,
        arg2: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn faiss_GpuClonerOptions_useFloat16(
        arg1: *const FaissGpuClonerOptions,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_GpuClonerOptions_set_useFloat16(
        arg1: *mut FaissGpuClonerOptions,
        arg2: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn faiss_GpuClonerOptions_usePrecomputed(
        arg1: *const FaissGpuClonerOptions,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_GpuClonerOptions_set_usePrecomputed(
        arg1: *mut FaissGpuClonerOptions,
        arg2: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn faiss_GpuClonerOptions_reserveVecs(
        arg1: *const FaissGpuClonerOptions,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn faiss_GpuClonerOptions_set_reserveVecs(
        arg1: *mut FaissGpuClonerOptions,
        arg2: ::std::os::raw::c_long,
    );
}
unsafe extern "C" {
    pub fn faiss_GpuClonerOptions_storeTransposed(
        arg1: *const FaissGpuClonerOptions,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_GpuClonerOptions_set_storeTransposed(
        arg1: *mut FaissGpuClonerOptions,
        arg2: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn faiss_GpuClonerOptions_verbose(
        arg1: *const FaissGpuClonerOptions,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_GpuClonerOptions_set_verbose(
        arg1: *mut FaissGpuClonerOptions,
        arg2: ::std::os::raw::c_int,
    );
}
pub type FaissGpuMultipleClonerOptions = FaissGpuClonerOptions_H;
unsafe extern "C" {
    pub fn faiss_GpuMultipleClonerOptions_free(obj: *mut FaissGpuMultipleClonerOptions);
}
unsafe extern "C" {
    #[doc = " Default constructor for GpuMultipleClonerOptions"]
    pub fn faiss_GpuMultipleClonerOptions_new(
        arg1: *mut *mut FaissGpuMultipleClonerOptions,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_GpuMultipleClonerOptions_shard(
        arg1: *const FaissGpuMultipleClonerOptions,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_GpuMultipleClonerOptions_set_shard(
        arg1: *mut FaissGpuMultipleClonerOptions,
        arg2: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn faiss_GpuMultipleClonerOptions_shard_type(
        arg1: *const FaissGpuMultipleClonerOptions,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faiss_GpuMultipleClonerOptions_set_shard_type(
        arg1: *mut FaissGpuMultipleClonerOptions,
        arg2: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissGpuIndexConfig_H {
    _unused: [u8; 0],
}
pub type FaissGpuIndexConfig = FaissGpuIndexConfig_H;
unsafe extern "C" {
    pub fn faiss_GpuIndexConfig_device(arg1: *const FaissGpuIndexConfig) -> ::std::os::raw::c_int;
}
pub type FaissGpuIndex = FaissIndex_H;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissGpuResources_H {
    _unused: [u8; 0],
}
pub type FaissGpuResources = FaissGpuResources_H;
unsafe extern "C" {
    pub fn faiss_GpuResources_free(obj: *mut FaissGpuResources);
}
unsafe extern "C" {
    #[doc = " Call to pre-allocate resources for a particular device. If this is\n not called, then resources will be allocated at the first time\n of demand"]
    pub fn faiss_GpuResources_initializeForDevice(
        arg1: *mut FaissGpuResources,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Returns the cuBLAS handle that we use for the given device"]
    pub fn faiss_GpuResources_getBlasHandle(
        arg1: *mut FaissGpuResources,
        arg2: ::std::os::raw::c_int,
        arg3: *mut cublasHandle_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Returns the stream that we order all computation on for the\n given device"]
    pub fn faiss_GpuResources_getDefaultStream(
        arg1: *mut FaissGpuResources,
        arg2: ::std::os::raw::c_int,
        arg3: *mut cudaStream_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Returns the available CPU pinned memory buffer"]
    pub fn faiss_GpuResources_getPinnedMemory(
        arg1: *mut FaissGpuResources,
        arg2: *mut *mut ::std::os::raw::c_void,
        arg3: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Returns the stream on which we perform async CPU <-> GPU copies"]
    pub fn faiss_GpuResources_getAsyncCopyStream(
        arg1: *mut FaissGpuResources,
        arg2: ::std::os::raw::c_int,
        arg3: *mut cudaStream_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Calls getBlasHandle with the current device"]
    pub fn faiss_GpuResources_getBlasHandleCurrentDevice(
        arg1: *mut FaissGpuResources,
        arg2: *mut cublasHandle_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Calls getDefaultStream with the current device"]
    pub fn faiss_GpuResources_getDefaultStreamCurrentDevice(
        arg1: *mut FaissGpuResources,
        arg2: *mut cudaStream_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Synchronizes the CPU with respect to the default stream for the\n given device"]
    pub fn faiss_GpuResources_syncDefaultStream(
        arg1: *mut FaissGpuResources,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Calls syncDefaultStream for the current device"]
    pub fn faiss_GpuResources_syncDefaultStreamCurrentDevice(
        arg1: *mut FaissGpuResources,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Calls getAsyncCopyStream for the current device"]
    pub fn faiss_GpuResources_getAsyncCopyStreamCurrentDevice(
        arg1: *mut FaissGpuResources,
        arg2: *mut cudaStream_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissGpuResourcesProvider_H {
    _unused: [u8; 0],
}
pub type FaissGpuResourcesProvider = FaissGpuResourcesProvider_H;
unsafe extern "C" {
    pub fn faiss_GpuResourcesProvider_free(obj: *mut FaissGpuResourcesProvider);
}
unsafe extern "C" {
    pub fn faiss_GpuResourcesProvider_getResources(
        arg1: *mut FaissGpuResourcesProvider,
        arg2: *mut *mut FaissGpuResources,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " converts any GPU index inside gpu_index to a CPU index"]
    pub fn faiss_index_gpu_to_cpu(
        gpu_index: *const FaissIndex,
        p_out: *mut *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " converts any CPU index that can be converted to GPU"]
    pub fn faiss_index_cpu_to_gpu(
        provider: *mut FaissGpuResourcesProvider,
        device: ::std::os::raw::c_int,
        index: *const FaissIndex,
        p_out: *mut *mut FaissGpuIndex,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " converts any CPU index that can be converted to GPU"]
    pub fn faiss_index_cpu_to_gpu_with_options(
        provider: *mut FaissGpuResourcesProvider,
        device: ::std::os::raw::c_int,
        index: *const FaissIndex,
        options: *const FaissGpuClonerOptions,
        p_out: *mut *mut FaissGpuIndex,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " converts any CPU index that can be converted to GPU"]
    pub fn faiss_index_cpu_to_gpu_multiple(
        providers_vec: *const *mut FaissGpuResourcesProvider,
        devices: *const ::std::os::raw::c_int,
        devices_size: usize,
        index: *const FaissIndex,
        p_out: *mut *mut FaissGpuIndex,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " converts any CPU index that can be converted to GPU"]
    pub fn faiss_index_cpu_to_gpu_multiple_with_options(
        providers_vec: *const *mut FaissGpuResourcesProvider,
        providers_vec_size: usize,
        devices: *const ::std::os::raw::c_int,
        devices_size: usize,
        index: *const FaissIndex,
        options: *const FaissGpuMultipleClonerOptions,
        p_out: *mut *mut FaissGpuIndex,
    ) -> ::std::os::raw::c_int;
}
pub type FaissGpuParameterSpace = FaissParameterSpace_H;
pub type FaissStandardGpuResources = FaissGpuResourcesProvider_H;
unsafe extern "C" {
    pub fn faiss_StandardGpuResources_free(obj: *mut FaissStandardGpuResources);
}
unsafe extern "C" {
    #[doc = " Default constructor for StandardGpuResources"]
    pub fn faiss_StandardGpuResources_new(
        arg1: *mut *mut FaissStandardGpuResources,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Disable allocation of temporary memory; all temporary memory\n requests will call cudaMalloc / cudaFree at the point of use"]
    pub fn faiss_StandardGpuResources_noTempMemory(
        arg1: *mut FaissStandardGpuResources,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Specify that we wish to use a certain fixed size of memory on\n all devices as temporary memory"]
    pub fn faiss_StandardGpuResources_setTempMemory(
        arg1: *mut FaissStandardGpuResources,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set amount of pinned memory to allocate, for async GPU <-> CPU\n transfers"]
    pub fn faiss_StandardGpuResources_setPinnedMemory(
        arg1: *mut FaissStandardGpuResources,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Called to change the stream for work ordering"]
    pub fn faiss_StandardGpuResources_setDefaultStream(
        arg1: *mut FaissStandardGpuResources,
        device: ::std::os::raw::c_int,
        stream: cudaStream_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Called to change the work ordering streams to the null stream\n for all devices"]
    pub fn faiss_StandardGpuResources_setDefaultNullStreamAllDevices(
        arg1: *mut FaissStandardGpuResources,
    ) -> ::std::os::raw::c_int;
}
