/* automatically generated by rust-bindgen 0.57.0 */

pub type __int64_t = ::std::os::raw::c_long;
pub type faiss_idx_t = i64;
pub type idx_t = faiss_idx_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissRangeSearchResult_H {
    _unused: [u8; 0],
}
pub type FaissRangeSearchResult = FaissRangeSearchResult_H;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIDSelector_H {
    _unused: [u8; 0],
}
pub type FaissIDSelector = FaissIDSelector_H;
#[doc = "< maximum inner product search"]
pub const FaissMetricType_METRIC_INNER_PRODUCT: FaissMetricType = 0;
#[doc = "< squared L2 search"]
pub const FaissMetricType_METRIC_L2: FaissMetricType = 1;
#[doc = "< L1 (aka cityblock)"]
pub const FaissMetricType_METRIC_L1: FaissMetricType = 2;
#[doc = "< infinity distance"]
pub const FaissMetricType_METRIC_Linf: FaissMetricType = 3;
#[doc = "< L_p distance, p is given by metric_arg"]
pub const FaissMetricType_METRIC_Lp: FaissMetricType = 4;
#[doc = " some additional metrics defined in scipy.spatial.distance"]
pub const FaissMetricType_METRIC_Canberra: FaissMetricType = 20;
#[doc = " some additional metrics defined in scipy.spatial.distance"]
pub const FaissMetricType_METRIC_BrayCurtis: FaissMetricType = 21;
#[doc = " some additional metrics defined in scipy.spatial.distance"]
pub const FaissMetricType_METRIC_JensenShannon: FaissMetricType = 22;
#[doc = " Some algorithms support both an inner product version and a L2 search"]
#[doc = " version."]
pub type FaissMetricType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIndex_H {
    _unused: [u8; 0],
}
pub type FaissIndex = FaissIndex_H;
extern "C" {
    pub fn faiss_Index_free(obj: *mut FaissIndex);
}
extern "C" {
    pub fn faiss_Index_d(arg1: *const FaissIndex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Index_is_trained(arg1: *const FaissIndex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Index_ntotal(arg1: *const FaissIndex) -> idx_t;
}
extern "C" {
    pub fn faiss_Index_metric_type(arg1: *const FaissIndex) -> FaissMetricType;
}
extern "C" {
    pub fn faiss_Index_verbose(arg1: *const FaissIndex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Index_set_verbose(arg1: *mut FaissIndex, arg2: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Perform training on a representative set of vectors"]
    #[doc = ""]
    #[doc = " @param index  opaque pointer to index object"]
    #[doc = " @param n      nb of training vectors"]
    #[doc = " @param x      training vectors, size n * d"]
    pub fn faiss_Index_train(
        index: *mut FaissIndex,
        n: idx_t,
        x: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add n vectors of dimension d to the index."]
    #[doc = ""]
    #[doc = " Vectors are implicitly assigned labels ntotal .. ntotal + n - 1"]
    #[doc = " This function slices the input vectors in chuncks smaller than"]
    #[doc = " blocksize_add and calls add_core."]
    #[doc = " @param index  opaque pointer to index object"]
    #[doc = " @param x      input matrix, size n * d"]
    pub fn faiss_Index_add(
        index: *mut FaissIndex,
        n: idx_t,
        x: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Same as add, but stores xids instead of sequential ids."]
    #[doc = ""]
    #[doc = " The default implementation fails with an assertion, as it is"]
    #[doc = " not supported by all indexes."]
    #[doc = ""]
    #[doc = " @param index  opaque pointer to index object"]
    #[doc = " @param xids   if non-null, ids to store for the vectors (size n)"]
    pub fn faiss_Index_add_with_ids(
        index: *mut FaissIndex,
        n: idx_t,
        x: *const f32,
        xids: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " query n vectors of dimension d to the index."]
    #[doc = ""]
    #[doc = " return at most k vectors. If there are not enough results for a"]
    #[doc = " query, the result array is padded with -1s."]
    #[doc = ""]
    #[doc = " @param index       opaque pointer to index object"]
    #[doc = " @param x           input vectors to search, size n * d"]
    #[doc = " @param labels      output labels of the NNs, size n*k"]
    #[doc = " @param distances   output pairwise distances, size n*k"]
    pub fn faiss_Index_search(
        index: *const FaissIndex,
        n: idx_t,
        x: *const f32,
        k: idx_t,
        distances: *mut f32,
        labels: *mut idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " query n vectors of dimension d to the index."]
    #[doc = ""]
    #[doc = " return all vectors with distance < radius. Note that many"]
    #[doc = " indexes do not implement the range_search (only the k-NN search"]
    #[doc = " is mandatory)."]
    #[doc = ""]
    #[doc = " @param index       opaque pointer to index object"]
    #[doc = " @param x           input vectors to search, size n * d"]
    #[doc = " @param radius      search radius"]
    #[doc = " @param result      result table"]
    pub fn faiss_Index_range_search(
        index: *const FaissIndex,
        n: idx_t,
        x: *const f32,
        radius: f32,
        result: *mut FaissRangeSearchResult,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " return the indexes of the k vectors closest to the query x."]
    #[doc = ""]
    #[doc = " This function is identical as search but only return labels of neighbors."]
    #[doc = " @param index       opaque pointer to index object"]
    #[doc = " @param x           input vectors to search, size n * d"]
    #[doc = " @param labels      output labels of the NNs, size n*k"]
    pub fn faiss_Index_assign(
        index: *mut FaissIndex,
        n: idx_t,
        x: *const f32,
        labels: *mut idx_t,
        k: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " removes all elements from the database."]
    #[doc = " @param index       opaque pointer to index object"]
    pub fn faiss_Index_reset(index: *mut FaissIndex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " removes IDs from the index. Not supported by all indexes"]
    #[doc = " @param index       opaque pointer to index object"]
    #[doc = " @param nremove     output for the number of IDs removed"]
    pub fn faiss_Index_remove_ids(
        index: *mut FaissIndex,
        sel: *const FaissIDSelector,
        n_removed: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reconstruct a stored vector (or an approximation if lossy coding)"]
    #[doc = ""]
    #[doc = " this function may not be defined for some indexes"]
    #[doc = " @param index       opaque pointer to index object"]
    #[doc = " @param key         id of the vector to reconstruct"]
    #[doc = " @param recons      reconstucted vector (size d)"]
    pub fn faiss_Index_reconstruct(
        index: *const FaissIndex,
        key: idx_t,
        recons: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reconstruct vectors i0 to i0 + ni - 1"]
    #[doc = ""]
    #[doc = " this function may not be defined for some indexes"]
    #[doc = " @param index       opaque pointer to index object"]
    #[doc = " @param recons      reconstucted vector (size ni * d)"]
    pub fn faiss_Index_reconstruct_n(
        index: *const FaissIndex,
        i0: idx_t,
        ni: idx_t,
        recons: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Computes a residual vector after indexing encoding."]
    #[doc = ""]
    #[doc = " The residual vector is the difference between a vector and the"]
    #[doc = " reconstruction that can be decoded from its representation in"]
    #[doc = " the index. The residual can be used for multiple-stage indexing"]
    #[doc = " methods, like IndexIVF's methods."]
    #[doc = ""]
    #[doc = " @param index       opaque pointer to index object"]
    #[doc = " @param x           input vector, size d"]
    #[doc = " @param residual    output residual vector, size d"]
    #[doc = " @param key         encoded index, as returned by search and assign"]
    pub fn faiss_Index_compute_residual(
        index: *const FaissIndex,
        x: *const f32,
        residual: *mut f32,
        key: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Computes a residual vector after indexing encoding."]
    #[doc = ""]
    #[doc = " The residual vector is the difference between a vector and the"]
    #[doc = " reconstruction that can be decoded from its representation in"]
    #[doc = " the index. The residual can be used for multiple-stage indexing"]
    #[doc = " methods, like IndexIVF's methods."]
    #[doc = ""]
    #[doc = " @param index       opaque pointer to index object"]
    #[doc = " @param n           number of vectors"]
    #[doc = " @param x           input vector, size (n x d)"]
    #[doc = " @param residuals    output residual vectors, size (n x d)"]
    #[doc = " @param keys         encoded index, as returned by search and assign"]
    pub fn faiss_Index_compute_residual_n(
        index: *const FaissIndex,
        n: idx_t,
        x: *const f32,
        residuals: *mut f32,
        keys: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissParameterRange_H {
    _unused: [u8; 0],
}
pub type FaissParameterRange = FaissParameterRange_H;
extern "C" {
    pub fn faiss_ParameterRange_name(
        arg1: *const FaissParameterRange,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Getter for the values in the range. The output values are invalidated"]
    #[doc = " upon any other modification of the range."]
    pub fn faiss_ParameterRange_values(
        arg1: *mut FaissParameterRange,
        arg2: *mut *mut f64,
        arg3: *mut usize,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissParameterSpace_H {
    _unused: [u8; 0],
}
pub type FaissParameterSpace = FaissParameterSpace_H;
extern "C" {
    pub fn faiss_ParameterSpace_free(obj: *mut FaissParameterSpace);
}
extern "C" {
    #[doc = " Parameter space default constructor"]
    pub fn faiss_ParameterSpace_new(space: *mut *mut FaissParameterSpace) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " nb of combinations, = product of values sizes"]
    pub fn faiss_ParameterSpace_n_combinations(arg1: *const FaissParameterSpace) -> usize;
}
extern "C" {
    #[doc = " get string representation of the combination"]
    #[doc = " by writing it to the given character buffer."]
    #[doc = " A buffer size of 1000 ensures that the full name is collected."]
    pub fn faiss_ParameterSpace_combination_name(
        arg1: *const FaissParameterSpace,
        arg2: usize,
        arg3: *mut ::std::os::raw::c_char,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " set a combination of parameters described by a string"]
    pub fn faiss_ParameterSpace_set_index_parameters(
        arg1: *const FaissParameterSpace,
        arg2: *mut FaissIndex,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " set a combination of parameters on an index"]
    pub fn faiss_ParameterSpace_set_index_parameters_cno(
        arg1: *const FaissParameterSpace,
        arg2: *mut FaissIndex,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " set one of the parameters"]
    pub fn faiss_ParameterSpace_set_index_parameter(
        arg1: *const FaissParameterSpace,
        arg2: *mut FaissIndex,
        arg3: *const ::std::os::raw::c_char,
        arg4: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " print a description on stdout"]
    pub fn faiss_ParameterSpace_display(arg1: *const FaissParameterSpace);
}
extern "C" {
    #[doc = " add a new parameter (or return it if it exists)"]
    pub fn faiss_ParameterSpace_add_range(
        arg1: *mut FaissParameterSpace,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut FaissParameterRange,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Class for the clustering parameters. Can be passed to the"]
#[doc = " constructor of the Clustering object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissClusteringParameters {
    #[doc = "< clustering iterations"]
    pub niter: ::std::os::raw::c_int,
    #[doc = "< redo clustering this many times and keep best"]
    pub nredo: ::std::os::raw::c_int,
    #[doc = "< (bool)"]
    pub verbose: ::std::os::raw::c_int,
    #[doc = "< (bool) do we want normalized centroids?"]
    pub spherical: ::std::os::raw::c_int,
    #[doc = "< (bool) update index after each iteration?"]
    pub update_index: ::std::os::raw::c_int,
    #[doc = "< (bool) use the centroids provided as input and do"]
    #[doc = "< not change them during iterations"]
    pub frozen_centroids: ::std::os::raw::c_int,
    #[doc = "< otherwise you get a warning"]
    pub min_points_per_centroid: ::std::os::raw::c_int,
    #[doc = "< to limit size of dataset"]
    pub max_points_per_centroid: ::std::os::raw::c_int,
    #[doc = "< seed for the random number generator"]
    pub seed: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_FaissClusteringParameters() {
    assert_eq!(
        ::std::mem::size_of::<FaissClusteringParameters>(),
        36usize,
        concat!("Size of: ", stringify!(FaissClusteringParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<FaissClusteringParameters>(),
        4usize,
        concat!("Alignment of ", stringify!(FaissClusteringParameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FaissClusteringParameters>())).niter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(niter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FaissClusteringParameters>())).nredo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(nredo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FaissClusteringParameters>())).verbose as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(verbose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FaissClusteringParameters>())).spherical as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(spherical)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FaissClusteringParameters>())).update_index as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(update_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FaissClusteringParameters>())).frozen_centroids as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(frozen_centroids)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FaissClusteringParameters>())).min_points_per_centroid
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(min_points_per_centroid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FaissClusteringParameters>())).max_points_per_centroid
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(max_points_per_centroid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FaissClusteringParameters>())).seed as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissClusteringParameters),
            "::",
            stringify!(seed)
        )
    );
}
extern "C" {
    #[doc = " Sets the ClusteringParameters object with reasonable defaults"]
    pub fn faiss_ClusteringParameters_init(params: *mut FaissClusteringParameters);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissClustering_H {
    _unused: [u8; 0],
}
pub type FaissClustering = FaissClustering_H;
extern "C" {
    pub fn faiss_Clustering_niter(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_nredo(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_verbose(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_spherical(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_update_index(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_frozen_centroids(arg1: *const FaissClustering)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_min_points_per_centroid(
        arg1: *const FaissClustering,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_max_points_per_centroid(
        arg1: *const FaissClustering,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_seed(arg1: *const FaissClustering) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_d(arg1: *const FaissClustering) -> usize;
}
extern "C" {
    pub fn faiss_Clustering_k(arg1: *const FaissClustering) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissClusteringIterationStats_H {
    _unused: [u8; 0],
}
pub type FaissClusteringIterationStats = FaissClusteringIterationStats_H;
extern "C" {
    pub fn faiss_ClusteringIterationStats_obj(arg1: *const FaissClusteringIterationStats) -> f32;
}
extern "C" {
    pub fn faiss_ClusteringIterationStats_time(arg1: *const FaissClusteringIterationStats) -> f64;
}
extern "C" {
    pub fn faiss_ClusteringIterationStats_time_search(
        arg1: *const FaissClusteringIterationStats,
    ) -> f64;
}
extern "C" {
    pub fn faiss_ClusteringIterationStats_imbalance_factor(
        arg1: *const FaissClusteringIterationStats,
    ) -> f64;
}
extern "C" {
    pub fn faiss_ClusteringIterationStats_nsplit(
        arg1: *const FaissClusteringIterationStats,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " getter for centroids (size = k * d)"]
    pub fn faiss_Clustering_centroids(
        clustering: *mut FaissClustering,
        centroids: *mut *mut f32,
        size: *mut usize,
    );
}
extern "C" {
    #[doc = " getter for iteration stats"]
    pub fn faiss_Clustering_iteration_stats(
        clustering: *mut FaissClustering,
        iteration_stats: *mut *mut FaissClusteringIterationStats,
        size: *mut usize,
    );
}
extern "C" {
    #[doc = " the only mandatory parameters are k and d"]
    pub fn faiss_Clustering_new(
        p_clustering: *mut *mut FaissClustering,
        d: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_new_with_params(
        p_clustering: *mut *mut FaissClustering,
        d: ::std::os::raw::c_int,
        k: ::std::os::raw::c_int,
        cp: *const FaissClusteringParameters,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_train(
        clustering: *mut FaissClustering,
        n: idx_t,
        x: *const f32,
        index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_Clustering_free(clustering: *mut FaissClustering);
}
extern "C" {
    #[doc = " simplified interface"]
    #[doc = ""]
    #[doc = " @param d dimension of the data"]
    #[doc = " @param n nb of training vectors"]
    #[doc = " @param k nb of output centroids"]
    #[doc = " @param x training set (size n * d)"]
    #[doc = " @param centroids output centroids (size k * d)"]
    #[doc = " @param q_error final quantization error"]
    #[doc = " @return error code"]
    pub fn faiss_kmeans_clustering(
        d: usize,
        n: usize,
        k: usize,
        x: *const f32,
        centroids: *mut f32,
        q_error: *mut f32,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexFlat = FaissIndex_H;
extern "C" {
    #[doc = " Opaque type for IndexFlat"]
    pub fn faiss_IndexFlat_new(p_index: *mut *mut FaissIndexFlat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexFlat_new_with(
        p_index: *mut *mut FaissIndexFlat,
        d: idx_t,
        metric: FaissMetricType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get a pointer to the index's internal data (the `xb` field). The outputs"]
    #[doc = " become invalid after any data addition or removal operation."]
    #[doc = ""]
    #[doc = " @param index   opaque pointer to index object"]
    #[doc = " @param p_xb    output, the pointer to the beginning of `xb`."]
    #[doc = " @param p_size  output, the current size of `sb` in number of float values."]
    pub fn faiss_IndexFlat_xb(index: *mut FaissIndexFlat, p_xb: *mut *mut f32, p_size: *mut usize);
}
extern "C" {
    pub fn faiss_IndexFlat_cast(arg1: *mut FaissIndex) -> *mut FaissIndexFlat;
}
extern "C" {
    pub fn faiss_IndexFlat_free(obj: *mut FaissIndexFlat);
}
extern "C" {
    #[doc = " compute distance with a subset of vectors"]
    #[doc = ""]
    #[doc = " @param index   opaque pointer to index object"]
    #[doc = " @param x       query vectors, size n * d"]
    #[doc = " @param labels  indices of the vectors that should be compared"]
    #[doc = "                for each query vector, size n * k"]
    #[doc = " @param distances"]
    #[doc = "                corresponding output distances, size n * k"]
    pub fn faiss_IndexFlat_compute_distance_subset(
        index: *mut FaissIndex,
        n: idx_t,
        x: *const f32,
        k: idx_t,
        distances: *mut f32,
        labels: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexFlatIP = FaissIndex_H;
extern "C" {
    #[doc = " Opaque type for IndexFlatIP"]
    pub fn faiss_IndexFlatIP_new(p_index: *mut *mut FaissIndexFlatIP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexFlatIP_new_with(
        p_index: *mut *mut FaissIndexFlatIP,
        d: idx_t,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexFlatL2 = FaissIndex_H;
extern "C" {
    #[doc = " Opaque type for IndexFlatL2"]
    pub fn faiss_IndexFlatL2_new(p_index: *mut *mut FaissIndexFlatL2) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexFlatL2_new_with(
        p_index: *mut *mut FaissIndexFlatL2,
        d: idx_t,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexRefineFlat = FaissIndex_H;
extern "C" {
    #[doc = " Opaque type for IndexRefineFlat"]
    #[doc = ""]
    #[doc = " Index that queries in a base_index (a fast one) and refines the"]
    #[doc = " results with an exact search, hopefully improving the results."]
    pub fn faiss_IndexRefineFlat_new(
        p_index: *mut *mut FaissIndexRefineFlat,
        base_index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexRefineFlat_free(obj: *mut FaissIndexRefineFlat);
}
extern "C" {
    pub fn faiss_IndexRefineFlat_own_fields(
        arg1: *const FaissIndexRefineFlat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexRefineFlat_set_own_fields(
        arg1: *mut FaissIndexRefineFlat,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn faiss_IndexRefineFlat_k_factor(arg1: *const FaissIndexRefineFlat) -> f32;
}
extern "C" {
    pub fn faiss_IndexRefineFlat_set_k_factor(arg1: *mut FaissIndexRefineFlat, arg2: f32);
}
pub type FaissIndexFlat1D = FaissIndex_H;
extern "C" {
    #[doc = " Opaque type for IndexFlat1D"]
    #[doc = ""]
    #[doc = " optimized version for 1D \"vectors\""]
    pub fn faiss_IndexFlat1D_new(p_index: *mut *mut FaissIndexFlat1D) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexFlat1D_new_with(
        p_index: *mut *mut FaissIndexFlat1D,
        continuous_update: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexFlat1D_update_permutation(
        index: *mut FaissIndexFlat1D,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexIVFFlat = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexIVFFlat_free(obj: *mut FaissIndexIVFFlat);
}
extern "C" {
    pub fn faiss_IndexIVFFlat_cast(arg1: *mut FaissIndex) -> *mut FaissIndexIVFFlat;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_nlist(arg1: *const FaissIndexIVFFlat) -> usize;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_nprobe(arg1: *const FaissIndexIVFFlat) -> usize;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_set_nprobe(arg1: *mut FaissIndexIVFFlat, arg2: usize);
}
extern "C" {
    pub fn faiss_IndexIVFFlat_quantizer(arg1: *const FaissIndexIVFFlat) -> *mut FaissIndex;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_quantizer_trains_alone(
        arg1: *const FaissIndexIVFFlat,
    ) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_own_fields(arg1: *const FaissIndexIVFFlat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_set_own_fields(
        arg1: *mut FaissIndexIVFFlat,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " whether object owns the quantizer"]
    pub fn faiss_IndexIVFFlat_new(p_index: *mut *mut FaissIndexIVFFlat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_new_with(
        p_index: *mut *mut FaissIndexIVFFlat,
        quantizer: *mut FaissIndex,
        d: usize,
        nlist: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_new_with_metric(
        p_index: *mut *mut FaissIndexIVFFlat,
        quantizer: *mut FaissIndex,
        d: usize,
        nlist: usize,
        metric: FaissMetricType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFFlat_add_core(
        index: *mut FaissIndexIVFFlat,
        n: idx_t,
        x: *const f32,
        xids: *const idx_t,
        precomputed_idx: *const i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Update a subset of vectors."]
    #[doc = ""]
    #[doc = " The index must have a direct_map"]
    #[doc = ""]
    #[doc = " @param nv     nb of vectors to update"]
    #[doc = " @param idx    vector indices to update, size nv"]
    #[doc = " @param v      vectors of new values, size nv*d"]
    pub fn faiss_IndexIVFFlat_update_vectors(
        index: *mut FaissIndexIVFFlat,
        nv: ::std::os::raw::c_int,
        idx: *mut idx_t,
        v: *const f32,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexIVF = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexIVF_free(obj: *mut FaissIndexIVF);
}
extern "C" {
    pub fn faiss_IndexIVF_cast(arg1: *mut FaissIndex) -> *mut FaissIndexIVF;
}
extern "C" {
    pub fn faiss_IndexIVF_nlist(arg1: *const FaissIndexIVF) -> usize;
}
extern "C" {
    pub fn faiss_IndexIVF_nprobe(arg1: *const FaissIndexIVF) -> usize;
}
extern "C" {
    pub fn faiss_IndexIVF_set_nprobe(arg1: *mut FaissIndexIVF, arg2: usize);
}
extern "C" {
    pub fn faiss_IndexIVF_quantizer(arg1: *const FaissIndexIVF) -> *mut FaissIndex;
}
extern "C" {
    pub fn faiss_IndexIVF_quantizer_trains_alone(
        arg1: *const FaissIndexIVF,
    ) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn faiss_IndexIVF_own_fields(arg1: *const FaissIndexIVF) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVF_set_own_fields(arg1: *mut FaissIndexIVF, arg2: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " moves the entries from another dataset to self. On output,"]
    #[doc = " other is empty. add_id is added to all moved ids (for"]
    #[doc = " sequential ids, this would be this->ntotal"]
    pub fn faiss_IndexIVF_merge_from(
        index: *mut FaissIndexIVF,
        other: *mut FaissIndexIVF,
        add_id: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " copy a subset of the entries index to the other index"]
    #[doc = ""]
    #[doc = " if subset_type == 0: copies ids in [a1, a2)"]
    #[doc = " if subset_type == 1: copies ids if id % a1 == a2"]
    #[doc = " if subset_type == 2: copies inverted lists such that a1"]
    #[doc = "                      elements are left before and a2 elements are after"]
    pub fn faiss_IndexIVF_copy_subset_to(
        index: *const FaissIndexIVF,
        other: *mut FaissIndexIVF,
        subset_type: ::std::os::raw::c_int,
        a1: idx_t,
        a2: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " search a set of vectors, that are pre-quantized by the IVF"]
    #[doc = "  quantizer. Fill in the corresponding heaps with the query"]
    #[doc = "  results. search() calls this."]
    #[doc = ""]
    #[doc = " @param n      nb of vectors to query"]
    #[doc = " @param x      query vectors, size nx * d"]
    #[doc = " @param assign coarse quantization indices, size nx * nprobe"]
    #[doc = " @param centroid_dis"]
    #[doc = "               distances to coarse centroids, size nx * nprobe"]
    #[doc = " @param distance"]
    #[doc = "               output distances, size n * k"]
    #[doc = " @param labels output labels, size n * k"]
    #[doc = " @param store_pairs store inv list index + inv list offset"]
    #[doc = "                     instead in upper/lower 32 bit of result,"]
    #[doc = "                     instead of ids (used for reranking)."]
    pub fn faiss_IndexIVF_search_preassigned(
        index: *const FaissIndexIVF,
        n: idx_t,
        x: *const f32,
        k: idx_t,
        assign: *const idx_t,
        centroid_dis: *const f32,
        distances: *mut f32,
        labels: *mut idx_t,
        store_pairs: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVF_get_list_size(index: *const FaissIndexIVF, list_no: usize) -> usize;
}
extern "C" {
    #[doc = " initialize a direct map"]
    #[doc = ""]
    #[doc = " @param new_maintain_direct_map    if true, create a direct map,"]
    #[doc = "                                   else clear it"]
    pub fn faiss_IndexIVF_make_direct_map(
        index: *mut FaissIndexIVF,
        new_maintain_direct_map: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check the inverted lists' imbalance factor."]
    #[doc = ""]
    #[doc = " 1= perfectly balanced, >1: imbalanced"]
    pub fn faiss_IndexIVF_imbalance_factor(index: *const FaissIndexIVF) -> f64;
}
extern "C" {
    #[doc = " display some stats about the inverted lists of the index"]
    pub fn faiss_IndexIVF_print_stats(index: *const FaissIndexIVF);
}
extern "C" {
    #[doc = " Get the IDs in an inverted list. IDs are written to `invlist`, which must be"]
    #[doc = " large enough"]
    #[doc = " to accommodate the full list."]
    #[doc = ""]
    #[doc = " @param list_no the list ID"]
    #[doc = " @param invlist output pointer to a slice of memory, at least as long as the"]
    #[doc = " list's size"]
    #[doc = " @see faiss_IndexIVF_get_list_size(size_t)"]
    pub fn faiss_IndexIVF_invlists_get_ids(
        index: *const FaissIndexIVF,
        list_no: usize,
        invlist: *mut idx_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIndexIVFStats {
    pub nq: usize,
    pub nlist: usize,
    pub ndis: usize,
}
#[test]
fn bindgen_test_layout_FaissIndexIVFStats() {
    assert_eq!(
        ::std::mem::size_of::<FaissIndexIVFStats>(),
        24usize,
        concat!("Size of: ", stringify!(FaissIndexIVFStats))
    );
    assert_eq!(
        ::std::mem::align_of::<FaissIndexIVFStats>(),
        8usize,
        concat!("Alignment of ", stringify!(FaissIndexIVFStats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FaissIndexIVFStats>())).nq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissIndexIVFStats),
            "::",
            stringify!(nq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FaissIndexIVFStats>())).nlist as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissIndexIVFStats),
            "::",
            stringify!(nlist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FaissIndexIVFStats>())).ndis as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissIndexIVFStats),
            "::",
            stringify!(ndis)
        )
    );
}
extern "C" {
    pub fn faiss_IndexIVFStats_reset(stats: *mut FaissIndexIVFStats);
}
pub type FaissIndexLSH = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexLSH_free(obj: *mut FaissIndexLSH);
}
extern "C" {
    pub fn faiss_IndexLSH_cast(arg1: *mut FaissIndex) -> *mut FaissIndexLSH;
}
extern "C" {
    pub fn faiss_IndexLSH_nbits(arg1: *const FaissIndexLSH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexLSH_bytes_per_vec(arg1: *const FaissIndexLSH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexLSH_rotate_data(arg1: *const FaissIndexLSH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexLSH_train_thresholds(arg1: *const FaissIndexLSH) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The sign of each vector component is put in a binary signature"]
    pub fn faiss_IndexLSH_new(
        p_index: *mut *mut FaissIndexLSH,
        d: idx_t,
        nbits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexLSH_new_with_options(
        p_index: *mut *mut FaissIndexLSH,
        d: idx_t,
        nbits: ::std::os::raw::c_int,
        rotate_data: ::std::os::raw::c_int,
        train_thresholds: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissVectorTransform_H {
    _unused: [u8; 0],
}
pub type FaissVectorTransform = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_VectorTransform_free(obj: *mut FaissVectorTransform);
}
extern "C" {
    pub fn faiss_VectorTransform_is_trained(
        arg1: *const FaissVectorTransform,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_VectorTransform_d_in(arg1: *const FaissVectorTransform) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_VectorTransform_d_out(arg1: *const FaissVectorTransform) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Perform training on a representative set of vectors"]
    #[doc = ""]
    #[doc = " @param vt     opaque pointer to VectorTransform object"]
    #[doc = " @param n      nb of training vectors"]
    #[doc = " @param x      training vectors, size n * d"]
    pub fn faiss_VectorTransform_train(
        vt: *mut FaissVectorTransform,
        n: idx_t,
        x: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " apply the random rotation, return new allocated matrix"]
    #[doc = " @param     x size n * d_in"]
    #[doc = " @return    size n * d_out"]
    pub fn faiss_VectorTransform_apply(
        vt: *const FaissVectorTransform,
        n: idx_t,
        x: *const f32,
    ) -> *mut f32;
}
extern "C" {
    #[doc = " apply transformation and result is pre-allocated"]
    #[doc = " @param     x size n * d_in"]
    #[doc = " @param     xt size n * d_out"]
    pub fn faiss_VectorTransform_apply_noalloc(
        vt: *const FaissVectorTransform,
        n: idx_t,
        x: *const f32,
        xt: *mut f32,
    );
}
extern "C" {
    #[doc = " reverse transformation. May not be implemented or may return"]
    #[doc = " approximate result"]
    pub fn faiss_VectorTransform_reverse_transform(
        vt: *const FaissVectorTransform,
        n: idx_t,
        xt: *const f32,
        x: *mut f32,
    );
}
pub type FaissLinearTransform = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_LinearTransform_free(obj: *mut FaissLinearTransform);
}
extern "C" {
    #[doc = " compute x = A^T * (x - b)"]
    #[doc = " is reverse transform if A has orthonormal lines"]
    pub fn faiss_LinearTransform_transform_transpose(
        vt: *const FaissLinearTransform,
        n: idx_t,
        y: *const f32,
        x: *mut f32,
    );
}
extern "C" {
    #[doc = " compute A^T * A to set the is_orthonormal flag"]
    pub fn faiss_LinearTransform_set_is_orthonormal(vt: *mut FaissLinearTransform);
}
extern "C" {
    pub fn faiss_LinearTransform_have_bias(
        arg1: *const FaissLinearTransform,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_LinearTransform_is_orthonormal(
        arg1: *const FaissLinearTransform,
    ) -> ::std::os::raw::c_int;
}
pub type FaissRandomRotationMatrix = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_RandomRotationMatrix_free(obj: *mut FaissRandomRotationMatrix);
}
extern "C" {
    #[doc = " Getter for is_orthonormal"]
    pub fn faiss_RandomRotationMatrix_new_with(
        p_vt: *mut *mut FaissRandomRotationMatrix,
        d_in: ::std::os::raw::c_int,
        d_out: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type FaissPCAMatrix = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_PCAMatrix_free(obj: *mut FaissPCAMatrix);
}
extern "C" {
    pub fn faiss_PCAMatrix_new_with(
        p_vt: *mut *mut FaissPCAMatrix,
        d_in: ::std::os::raw::c_int,
        d_out: ::std::os::raw::c_int,
        eigen_power: f32,
        random_rotation: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_PCAMatrix_eigen_power(arg1: *const FaissPCAMatrix) -> f32;
}
extern "C" {
    pub fn faiss_PCAMatrix_random_rotation(arg1: *const FaissPCAMatrix) -> ::std::os::raw::c_int;
}
pub type FaissITQMatrix = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_ITQMatrix_free(obj: *mut FaissITQMatrix);
}
extern "C" {
    #[doc = " Getter for random_rotation"]
    pub fn faiss_ITQMatrix_new_with(
        p_vt: *mut *mut FaissITQMatrix,
        d: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type FaissITQTransform = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_ITQTransform_free(obj: *mut FaissITQTransform);
}
extern "C" {
    pub fn faiss_ITQTransform_new_with(
        p_vt: *mut *mut FaissITQTransform,
        d_in: ::std::os::raw::c_int,
        d_out: ::std::os::raw::c_int,
        do_pca: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_ITQTransform_do_pca(arg1: *const FaissITQTransform) -> ::std::os::raw::c_int;
}
pub type FaissOPQMatrix = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_OPQMatrix_free(obj: *mut FaissOPQMatrix);
}
extern "C" {
    #[doc = " Getter for do_pca"]
    pub fn faiss_OPQMatrix_new_with(
        p_vt: *mut *mut FaissOPQMatrix,
        d: ::std::os::raw::c_int,
        M: ::std::os::raw::c_int,
        d2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_OPQMatrix_verbose(arg1: *const FaissOPQMatrix) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_OPQMatrix_set_verbose(arg1: *mut FaissOPQMatrix, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn faiss_OPQMatrix_niter(arg1: *const FaissOPQMatrix) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_OPQMatrix_set_niter(arg1: *mut FaissOPQMatrix, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn faiss_OPQMatrix_niter_pq(arg1: *const FaissOPQMatrix) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_OPQMatrix_set_niter_pq(arg1: *mut FaissOPQMatrix, arg2: ::std::os::raw::c_int);
}
pub type FaissRemapDimensionsTransform = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_RemapDimensionsTransform_free(obj: *mut FaissRemapDimensionsTransform);
}
extern "C" {
    pub fn faiss_RemapDimensionsTransform_new_with(
        p_vt: *mut *mut FaissRemapDimensionsTransform,
        d_in: ::std::os::raw::c_int,
        d_out: ::std::os::raw::c_int,
        uniform: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type FaissNormalizationTransform = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_NormalizationTransform_free(obj: *mut FaissNormalizationTransform);
}
extern "C" {
    pub fn faiss_NormalizationTransform_new_with(
        p_vt: *mut *mut FaissNormalizationTransform,
        d: ::std::os::raw::c_int,
        norm: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_NormalizationTransform_norm(arg1: *const FaissNormalizationTransform) -> f32;
}
pub type FaissCenteringTransform = FaissVectorTransform_H;
extern "C" {
    pub fn faiss_CenteringTransform_free(obj: *mut FaissCenteringTransform);
}
extern "C" {
    pub fn faiss_CenteringTransform_new_with(
        p_vt: *mut *mut FaissCenteringTransform,
        d: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexPreTransform = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexPreTransform_free(obj: *mut FaissIndexPreTransform);
}
extern "C" {
    pub fn faiss_IndexPreTransform_cast(arg1: *mut FaissIndex) -> *mut FaissIndexPreTransform;
}
extern "C" {
    pub fn faiss_IndexPreTransform_index(arg1: *const FaissIndexPreTransform) -> *mut FaissIndex;
}
extern "C" {
    pub fn faiss_IndexPreTransform_own_fields(
        arg1: *const FaissIndexPreTransform,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexPreTransform_set_own_fields(
        arg1: *mut FaissIndexPreTransform,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Index that applies a LinearTransform transform on vectors before"]
    #[doc = "  handing them over to a sub-index"]
    pub fn faiss_IndexPreTransform_new(
        p_index: *mut *mut FaissIndexPreTransform,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexPreTransform_new_with(
        p_index: *mut *mut FaissIndexPreTransform,
        index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexPreTransform_new_with_transform(
        p_index: *mut *mut FaissIndexPreTransform,
        ltrans: *mut FaissVectorTransform,
        index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< 8 bits per component"]
pub const FaissQuantizerType_QT_8bit: FaissQuantizerType = 0;
#[doc = "< 4 bits per component"]
pub const FaissQuantizerType_QT_4bit: FaissQuantizerType = 1;
#[doc = "< same, shared range for all dimensions"]
pub const FaissQuantizerType_QT_8bit_uniform: FaissQuantizerType = 2;
pub const FaissQuantizerType_QT_4bit_uniform: FaissQuantizerType = 3;
pub const FaissQuantizerType_QT_fp16: FaissQuantizerType = 4;
#[doc = "< fast indexing of uint8s"]
pub const FaissQuantizerType_QT_8bit_direct: FaissQuantizerType = 5;
#[doc = "< 6 bits per component"]
pub const FaissQuantizerType_QT_6bit: FaissQuantizerType = 6;
pub type FaissQuantizerType = ::std::os::raw::c_uint;
pub type FaissIndexScalarQuantizer = FaissIndex_H;
extern "C" {
    #[doc = " Opaque type for IndexScalarQuantizer"]
    pub fn faiss_IndexScalarQuantizer_new(
        p_index: *mut *mut FaissIndexScalarQuantizer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexScalarQuantizer_new_with(
        p_index: *mut *mut FaissIndexScalarQuantizer,
        d: idx_t,
        qt: FaissQuantizerType,
        metric: FaissMetricType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexScalarQuantizer_cast(arg1: *mut FaissIndex)
        -> *mut FaissIndexScalarQuantizer;
}
extern "C" {
    pub fn faiss_IndexScalarQuantizer_free(obj: *mut FaissIndexScalarQuantizer);
}
pub type FaissIndexIVFScalarQuantizer = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_cast(
        arg1: *mut FaissIndex,
    ) -> *mut FaissIndexIVFScalarQuantizer;
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_free(obj: *mut FaissIndexIVFScalarQuantizer);
}
extern "C" {
    #[doc = " Opaque type for IndexIVFScalarQuantizer"]
    pub fn faiss_IndexIVFScalarQuantizer_new(
        p_index: *mut *mut FaissIndexIVFScalarQuantizer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_new_with(
        p_index: *mut *mut FaissIndexIVFScalarQuantizer,
        quantizer: *mut FaissIndex,
        d: idx_t,
        nlist: usize,
        qt: FaissQuantizerType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_new_with_metric(
        p_index: *mut *mut FaissIndexIVFScalarQuantizer,
        quantizer: *mut FaissIndex,
        d: usize,
        nlist: usize,
        qt: FaissQuantizerType,
        metric: FaissMetricType,
        encode_residual: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_nlist(arg1: *const FaissIndexIVFScalarQuantizer) -> usize;
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_nprobe(arg1: *const FaissIndexIVFScalarQuantizer)
        -> usize;
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_set_nprobe(
        arg1: *mut FaissIndexIVFScalarQuantizer,
        arg2: usize,
    );
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_quantizer(
        arg1: *const FaissIndexIVFScalarQuantizer,
    ) -> *mut FaissIndex;
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_own_fields(
        arg1: *const FaissIndexIVFScalarQuantizer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_set_own_fields(
        arg1: *mut FaissIndexIVFScalarQuantizer,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " whether object owns the quantizer"]
    pub fn faiss_IndexIVFScalarQuantizer_add_core(
        index: *mut FaissIndexIVFScalarQuantizer,
        n: idx_t,
        x: *const f32,
        xids: *const idx_t,
        precomputed_idx: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIVFScalarQuantizer_train_residual(
        index: *mut FaissIndexIVFScalarQuantizer,
        n: idx_t,
        x: *const f32,
    ) -> ::std::os::raw::c_int;
}
pub type FaissIndexShards = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexShards_own_fields(arg1: *const FaissIndexShards) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexShards_set_own_fields(
        arg1: *mut FaissIndexShards,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn faiss_IndexShards_successive_ids(arg1: *const FaissIndexShards)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexShards_set_successive_ids(
        arg1: *mut FaissIndexShards,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Index that concatenates the results from several sub-indexes"]
    pub fn faiss_IndexShards_new(
        p_index: *mut *mut FaissIndexShards,
        d: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexShards_new_with_options(
        p_index: *mut *mut FaissIndexShards,
        d: idx_t,
        threaded: ::std::os::raw::c_int,
        successive_ids: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexShards_add_shard(
        index: *mut FaissIndexShards,
        shard: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexShards_at(
        index: *mut FaissIndexShards,
        i: ::std::os::raw::c_int,
    ) -> *mut FaissIndex;
}
pub type FaissIndexIDMap = FaissIndex_H;
extern "C" {
    pub fn faiss_IndexIDMap_own_fields(arg1: *const FaissIndexIDMap) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IndexIDMap_set_own_fields(arg1: *mut FaissIndexIDMap, arg2: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Index that translates search results to ids"]
    pub fn faiss_IndexIDMap_new(
        p_index: *mut *mut FaissIndexIDMap,
        index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get a pointer to the index map's internal ID vector (the `id_map` field)."]
    #[doc = " The outputs of this function become invalid after any operation that can"]
    #[doc = " modify the index."]
    #[doc = ""]
    #[doc = " @param index   opaque pointer to index object"]
    #[doc = " @param p_id_map    output, the pointer to the beginning of `id_map`."]
    #[doc = " @param p_size  output, the current length of `id_map`."]
    pub fn faiss_IndexIDMap_id_map(
        index: *mut FaissIndexIDMap,
        p_id_map: *mut *mut idx_t,
        p_size: *mut usize,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIndexIDMap_H {
    _unused: [u8; 0],
}
pub type FaissIndexIDMap2 = FaissIndexIDMap_H;
extern "C" {
    #[doc = " same as IndexIDMap but also provides an efficient reconstruction"]
    #[doc = "implementation via a 2-way index"]
    pub fn faiss_IndexIDMap2_new(
        p_index: *mut *mut FaissIndexIDMap2,
        index: *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " make the rev_map from scratch"]
    pub fn faiss_IndexIDMap2_construct_rev_map(
        index: *mut FaissIndexIDMap2,
    ) -> ::std::os::raw::c_int;
}
pub type FILE = [u64; 27usize];
extern "C" {
    #[doc = " Clone an index. This is equivalent to `faiss::clone_index`"]
    pub fn faiss_clone_index(
        arg1: *const FaissIndex,
        p_out: *mut *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
#[doc = " No error"]
pub const FaissErrorCode_OK: FaissErrorCode = 0;
#[doc = " Any exception other than Faiss or standard C++ library exceptions"]
pub const FaissErrorCode_UNKNOWN_EXCEPT: FaissErrorCode = -1;
#[doc = " Faiss library exception"]
pub const FaissErrorCode_FAISS_EXCEPT: FaissErrorCode = -2;
#[doc = " Standard C++ library exception"]
pub const FaissErrorCode_STD_EXCEPT: FaissErrorCode = -4;
#[doc = " An error code which depends on the exception thrown from the previous"]
#[doc = " operation. See `faiss_get_last_error` to retrieve the error message."]
pub type FaissErrorCode = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Get the error message of the last failed operation performed by Faiss."]
    #[doc = " The given pointer is only invalid until another Faiss function is"]
    #[doc = " called."]
    pub fn faiss_get_last_error() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn faiss_RangeSearchResult_nq(arg1: *const FaissRangeSearchResult) -> usize;
}
extern "C" {
    pub fn faiss_RangeSearchResult_new(
        p_rsr: *mut *mut FaissRangeSearchResult,
        nq: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_RangeSearchResult_new_with(
        p_rsr: *mut *mut FaissRangeSearchResult,
        nq: idx_t,
        alloc_lims: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " called when lims contains the nb of elements result entries"]
    #[doc = " for each query"]
    pub fn faiss_RangeSearchResult_do_allocation(
        rsr: *mut FaissRangeSearchResult,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_RangeSearchResult_free(obj: *mut FaissRangeSearchResult);
}
extern "C" {
    pub fn faiss_RangeSearchResult_buffer_size(arg1: *const FaissRangeSearchResult) -> usize;
}
extern "C" {
    #[doc = " getter for lims: size (nq + 1)"]
    pub fn faiss_RangeSearchResult_lims(rsr: *mut FaissRangeSearchResult, lims: *mut *mut usize);
}
extern "C" {
    #[doc = " getter for labels and respective distances (not sorted):"]
    #[doc = " result for query i is labels[lims[i]:lims[i+1]]"]
    pub fn faiss_RangeSearchResult_labels(
        rsr: *mut FaissRangeSearchResult,
        labels: *mut *mut idx_t,
        distances: *mut *mut f32,
    );
}
extern "C" {
    pub fn faiss_IDSelector_free(obj: *mut FaissIDSelector);
}
extern "C" {
    #[doc = " Encapsulates a set of ids to remove."]
    pub fn faiss_IDSelector_is_member(
        sel: *const FaissIDSelector,
        id: idx_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIDSelectorRange_H {
    _unused: [u8; 0],
}
pub type FaissIDSelectorRange = FaissIDSelectorRange_H;
extern "C" {
    pub fn faiss_IDSelectorRange_free(obj: *mut FaissIDSelectorRange);
}
extern "C" {
    pub fn faiss_IDSelectorRange_imin(arg1: *const FaissIDSelectorRange) -> idx_t;
}
extern "C" {
    pub fn faiss_IDSelectorRange_imax(arg1: *const FaissIDSelectorRange) -> idx_t;
}
extern "C" {
    #[doc = " remove ids between [imni, imax)"]
    pub fn faiss_IDSelectorRange_new(
        p_sel: *mut *mut FaissIDSelectorRange,
        imin: idx_t,
        imax: idx_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissIDSelectorBatch_H {
    _unused: [u8; 0],
}
pub type FaissIDSelectorBatch = FaissIDSelectorBatch_H;
extern "C" {
    pub fn faiss_IDSelectorBatch_nbits(arg1: *const FaissIDSelectorBatch) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_IDSelectorBatch_mask(arg1: *const FaissIDSelectorBatch) -> idx_t;
}
extern "C" {
    #[doc = " Remove ids from a set. Repetitions of ids in the indices set"]
    #[doc = " passed to the constructor does not hurt performance. The hash"]
    #[doc = " function used for the bloom filter and GCC's implementation of"]
    #[doc = " unordered_set are just the least significant bits of the id. This"]
    #[doc = " works fine for random ids or ids in sequences but will produce many"]
    #[doc = " hash collisions if lsb's are always the same"]
    pub fn faiss_IDSelectorBatch_new(
        p_sel: *mut *mut FaissIDSelectorBatch,
        n: usize,
        indices: *const idx_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissBufferList_H {
    _unused: [u8; 0],
}
pub type FaissBufferList = FaissBufferList_H;
extern "C" {
    pub fn faiss_BufferList_free(obj: *mut FaissBufferList);
}
extern "C" {
    pub fn faiss_BufferList_buffer_size(arg1: *const FaissBufferList) -> usize;
}
extern "C" {
    pub fn faiss_BufferList_wp(arg1: *const FaissBufferList) -> usize;
}
#[doc = " List of temporary buffers used to store results before they are"]
#[doc = "  copied to the RangeSearchResult object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissBuffer {
    pub ids: *mut idx_t,
    pub dis: *mut f32,
}
#[test]
fn bindgen_test_layout_FaissBuffer() {
    assert_eq!(
        ::std::mem::size_of::<FaissBuffer>(),
        16usize,
        concat!("Size of: ", stringify!(FaissBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<FaissBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(FaissBuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FaissBuffer>())).ids as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissBuffer),
            "::",
            stringify!(ids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FaissBuffer>())).dis as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FaissBuffer),
            "::",
            stringify!(dis)
        )
    );
}
extern "C" {
    pub fn faiss_BufferList_append_buffer(bl: *mut FaissBufferList) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_BufferList_new(
        p_bl: *mut *mut FaissBufferList,
        buffer_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_BufferList_add(
        bl: *mut FaissBufferList,
        id: idx_t,
        dis: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " copy elemnts ofs:ofs+n-1 seen as linear data in the buffers to"]
    #[doc = " tables dest_ids, dest_dis"]
    pub fn faiss_BufferList_copy_range(
        bl: *mut FaissBufferList,
        ofs: usize,
        n: usize,
        dest_ids: *mut idx_t,
        dest_dis: *mut f32,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissRangeSearchPartialResult_H {
    _unused: [u8; 0],
}
pub type FaissRangeSearchPartialResult = FaissRangeSearchPartialResult_H;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissRangeQueryResult_H {
    _unused: [u8; 0],
}
pub type FaissRangeQueryResult = FaissRangeQueryResult_H;
extern "C" {
    pub fn faiss_RangeQueryResult_qno(arg1: *const FaissRangeQueryResult) -> idx_t;
}
extern "C" {
    pub fn faiss_RangeQueryResult_nres(arg1: *const FaissRangeQueryResult) -> usize;
}
extern "C" {
    pub fn faiss_RangeQueryResult_pres(
        arg1: *const FaissRangeQueryResult,
    ) -> *mut FaissRangeSearchPartialResult;
}
extern "C" {
    #[doc = " result structure for a single query"]
    pub fn faiss_RangeQueryResult_add(
        qr: *mut FaissRangeQueryResult,
        dis: f32,
        id: idx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_RangeSearchPartialResult_res(
        arg1: *const FaissRangeSearchPartialResult,
    ) -> *mut FaissRangeSearchResult;
}
extern "C" {
    pub fn faiss_RangeSearchPartialResult_new(
        p_res: *mut *mut FaissRangeSearchPartialResult,
        res_in: *mut FaissRangeSearchResult,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_RangeSearchPartialResult_finalize(
        res: *mut FaissRangeSearchPartialResult,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " called by range_search before do_allocation"]
    pub fn faiss_RangeSearchPartialResult_set_lims(
        res: *mut FaissRangeSearchPartialResult,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_RangeSearchPartialResult_new_result(
        res: *mut FaissRangeSearchPartialResult,
        qno: idx_t,
        qr: *mut *mut FaissRangeQueryResult,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissDistanceComputer_H {
    _unused: [u8; 0],
}
pub type FaissDistanceComputer = FaissDistanceComputer_H;
extern "C" {
    #[doc = " called before computing distances"]
    pub fn faiss_DistanceComputer_set_query(
        dc: *mut FaissDistanceComputer,
        x: *const f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compute distance of vector i to current query."]
    #[doc = " This function corresponds to the function call operator:"]
    #[doc = " DistanceComputer::operator()"]
    pub fn faiss_DistanceComputer_vector_to_query_dis(
        dc: *mut FaissDistanceComputer,
        i: idx_t,
        qd: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " compute distance between two stored vectors"]
    pub fn faiss_DistanceComputer_symmetric_dis(
        dc: *mut FaissDistanceComputer,
        i: idx_t,
        j: idx_t,
        vd: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_DistanceComputer_free(obj: *mut FaissDistanceComputer);
}
extern "C" {
    #[doc = " Build and index with the sequence of processing steps described in"]
    #[doc = "  the string."]
    pub fn faiss_index_factory(
        p_index: *mut *mut FaissIndex,
        d: ::std::os::raw::c_int,
        description: *const ::std::os::raw::c_char,
        metric: FaissMetricType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write index to a file."]
    #[doc = " This is equivalent to `faiss::write_index` when a file descriptor is"]
    #[doc = " provided."]
    pub fn faiss_write_index(idx: *const FaissIndex, f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write index to a file."]
    #[doc = " This is equivalent to `faiss::write_index` when a file path is provided."]
    pub fn faiss_write_index_fname(
        idx: *const FaissIndex,
        fname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read index from a file."]
    #[doc = " This is equivalent to `faiss:read_index` when a file descriptor is given."]
    pub fn faiss_read_index(
        f: *mut FILE,
        io_flags: ::std::os::raw::c_int,
        p_out: *mut *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read index from a file."]
    #[doc = " This is equivalent to `faiss:read_index` when a file path is given."]
    pub fn faiss_read_index_fname(
        fname: *const ::std::os::raw::c_char,
        io_flags: ::std::os::raw::c_int,
        p_out: *mut *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstream_st {
    _unused: [u8; 0],
}
#[doc = " CUDA stream"]
pub type cudaStream_t = *mut CUstream_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cublasContext {
    _unused: [u8; 0],
}
pub type cublasHandle_t = *mut cublasContext;
extern "C" {
    #[doc = " Returns the number of available GPU devices"]
    pub fn faiss_get_num_gpus(p_output: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Starts the CUDA profiler (exposed via SWIG)"]
    pub fn faiss_gpu_profiler_start() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stops the CUDA profiler (exposed via SWIG)"]
    pub fn faiss_gpu_profiler_stop() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Synchronizes the CPU against all devices (equivalent to"]
    #[doc = " cudaDeviceSynchronize for each device)"]
    pub fn faiss_gpu_sync_all_devices() -> ::std::os::raw::c_int;
}
#[doc = " The user indices are only stored on the CPU; the GPU returns"]
#[doc = " (inverted list, offset) to the CPU which is then translated to"]
#[doc = " the real user index."]
pub const FaissIndicesOptions_INDICES_CPU: FaissIndicesOptions = 0;
#[doc = " The indices are not stored at all, on either the CPU or"]
#[doc = " GPU. Only (inverted list, offset) is returned to the user as the"]
#[doc = " index."]
pub const FaissIndicesOptions_INDICES_IVF: FaissIndicesOptions = 1;
#[doc = " Indices are stored as 32 bit integers on the GPU, but returned"]
#[doc = " as 64 bit integers"]
pub const FaissIndicesOptions_INDICES_32_BIT: FaissIndicesOptions = 2;
#[doc = " Indices are stored as 64 bit integers on the GPU"]
pub const FaissIndicesOptions_INDICES_64_BIT: FaissIndicesOptions = 3;
#[doc = " How user vector index data is stored on the GPU"]
pub type FaissIndicesOptions = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissGpuClonerOptions_H {
    _unused: [u8; 0],
}
pub type FaissGpuClonerOptions = FaissGpuClonerOptions_H;
extern "C" {
    pub fn faiss_GpuClonerOptions_free(obj: *mut FaissGpuClonerOptions);
}
extern "C" {
    #[doc = " Default constructor for GpuClonerOptions"]
    pub fn faiss_GpuClonerOptions_new(
        arg1: *mut *mut FaissGpuClonerOptions,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_GpuClonerOptions_indicesOptions(
        arg1: *const FaissGpuClonerOptions,
    ) -> FaissIndicesOptions;
}
extern "C" {
    pub fn faiss_GpuClonerOptions_set_indicesOptions(
        arg1: *mut FaissGpuClonerOptions,
        arg2: FaissIndicesOptions,
    );
}
extern "C" {
    pub fn faiss_GpuClonerOptions_useFloat16CoarseQuantizer(
        arg1: *const FaissGpuClonerOptions,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_GpuClonerOptions_set_useFloat16CoarseQuantizer(
        arg1: *mut FaissGpuClonerOptions,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn faiss_GpuClonerOptions_useFloat16(
        arg1: *const FaissGpuClonerOptions,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_GpuClonerOptions_set_useFloat16(
        arg1: *mut FaissGpuClonerOptions,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn faiss_GpuClonerOptions_usePrecomputed(
        arg1: *const FaissGpuClonerOptions,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_GpuClonerOptions_set_usePrecomputed(
        arg1: *mut FaissGpuClonerOptions,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn faiss_GpuClonerOptions_reserveVecs(
        arg1: *const FaissGpuClonerOptions,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn faiss_GpuClonerOptions_set_reserveVecs(
        arg1: *mut FaissGpuClonerOptions,
        arg2: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn faiss_GpuClonerOptions_storeTransposed(
        arg1: *const FaissGpuClonerOptions,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_GpuClonerOptions_set_storeTransposed(
        arg1: *mut FaissGpuClonerOptions,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn faiss_GpuClonerOptions_verbose(
        arg1: *const FaissGpuClonerOptions,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_GpuClonerOptions_set_verbose(
        arg1: *mut FaissGpuClonerOptions,
        arg2: ::std::os::raw::c_int,
    );
}
pub type FaissGpuMultipleClonerOptions = FaissGpuClonerOptions_H;
extern "C" {
    pub fn faiss_GpuMultipleClonerOptions_free(obj: *mut FaissGpuMultipleClonerOptions);
}
extern "C" {
    #[doc = " Default constructor for GpuMultipleClonerOptions"]
    pub fn faiss_GpuMultipleClonerOptions_new(
        arg1: *mut *mut FaissGpuMultipleClonerOptions,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_GpuMultipleClonerOptions_shard(
        arg1: *const FaissGpuMultipleClonerOptions,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_GpuMultipleClonerOptions_set_shard(
        arg1: *mut FaissGpuMultipleClonerOptions,
        arg2: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn faiss_GpuMultipleClonerOptions_shard_type(
        arg1: *const FaissGpuMultipleClonerOptions,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faiss_GpuMultipleClonerOptions_set_shard_type(
        arg1: *mut FaissGpuMultipleClonerOptions,
        arg2: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissGpuIndexConfig_H {
    _unused: [u8; 0],
}
pub type FaissGpuIndexConfig = FaissGpuIndexConfig_H;
extern "C" {
    pub fn faiss_GpuIndexConfig_device(arg1: *const FaissGpuIndexConfig) -> ::std::os::raw::c_int;
}
pub type FaissGpuIndex = FaissIndex_H;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissGpuResources_H {
    _unused: [u8; 0],
}
pub type FaissGpuResources = FaissGpuResources_H;
extern "C" {
    pub fn faiss_GpuResources_free(obj: *mut FaissGpuResources);
}
extern "C" {
    #[doc = " Call to pre-allocate resources for a particular device. If this is"]
    #[doc = " not called, then resources will be allocated at the first time"]
    #[doc = " of demand"]
    pub fn faiss_GpuResources_initializeForDevice(
        arg1: *mut FaissGpuResources,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the cuBLAS handle that we use for the given device"]
    pub fn faiss_GpuResources_getBlasHandle(
        arg1: *mut FaissGpuResources,
        arg2: ::std::os::raw::c_int,
        arg3: *mut cublasHandle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the stream that we order all computation on for the"]
    #[doc = " given device"]
    pub fn faiss_GpuResources_getDefaultStream(
        arg1: *mut FaissGpuResources,
        arg2: ::std::os::raw::c_int,
        arg3: *mut cudaStream_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the available CPU pinned memory buffer"]
    pub fn faiss_GpuResources_getPinnedMemory(
        arg1: *mut FaissGpuResources,
        arg2: *mut *mut ::std::os::raw::c_void,
        arg3: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the stream on which we perform async CPU <-> GPU copies"]
    pub fn faiss_GpuResources_getAsyncCopyStream(
        arg1: *mut FaissGpuResources,
        arg2: ::std::os::raw::c_int,
        arg3: *mut cudaStream_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calls getBlasHandle with the current device"]
    pub fn faiss_GpuResources_getBlasHandleCurrentDevice(
        arg1: *mut FaissGpuResources,
        arg2: *mut cublasHandle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calls getDefaultStream with the current device"]
    pub fn faiss_GpuResources_getDefaultStreamCurrentDevice(
        arg1: *mut FaissGpuResources,
        arg2: *mut cudaStream_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Synchronizes the CPU with respect to the default stream for the"]
    #[doc = " given device"]
    pub fn faiss_GpuResources_syncDefaultStream(
        arg1: *mut FaissGpuResources,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calls syncDefaultStream for the current device"]
    pub fn faiss_GpuResources_syncDefaultStreamCurrentDevice(
        arg1: *mut FaissGpuResources,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calls getAsyncCopyStream for the current device"]
    pub fn faiss_GpuResources_getAsyncCopyStreamCurrentDevice(
        arg1: *mut FaissGpuResources,
        arg2: *mut cudaStream_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaissGpuResourcesProvider_H {
    _unused: [u8; 0],
}
pub type FaissGpuResourcesProvider = FaissGpuResourcesProvider_H;
extern "C" {
    pub fn faiss_GpuResourcesProvider_free(obj: *mut FaissGpuResourcesProvider);
}
extern "C" {
    pub fn faiss_GpuResourcesProvider_getResources(
        arg1: *mut FaissGpuResourcesProvider,
        arg2: *mut *mut FaissGpuResources,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " converts any GPU index inside gpu_index to a CPU index"]
    pub fn faiss_index_gpu_to_cpu(
        gpu_index: *const FaissIndex,
        p_out: *mut *mut FaissIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " converts any CPU index that can be converted to GPU"]
    pub fn faiss_index_cpu_to_gpu(
        provider: *mut FaissGpuResourcesProvider,
        device: ::std::os::raw::c_int,
        index: *const FaissIndex,
        p_out: *mut *mut FaissGpuIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " converts any CPU index that can be converted to GPU"]
    pub fn faiss_index_cpu_to_gpu_with_options(
        provider: *mut FaissGpuResourcesProvider,
        device: ::std::os::raw::c_int,
        index: *const FaissIndex,
        options: *const FaissGpuClonerOptions,
        p_out: *mut *mut FaissGpuIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " converts any CPU index that can be converted to GPU"]
    pub fn faiss_index_cpu_to_gpu_multiple(
        providers_vec: *const *mut FaissGpuResourcesProvider,
        devices: *const ::std::os::raw::c_int,
        devices_size: usize,
        index: *const FaissIndex,
        p_out: *mut *mut FaissGpuIndex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " converts any CPU index that can be converted to GPU"]
    pub fn faiss_index_cpu_to_gpu_multiple_with_options(
        providers_vec: *const *mut FaissGpuResourcesProvider,
        providers_vec_size: usize,
        devices: *const ::std::os::raw::c_int,
        devices_size: usize,
        index: *const FaissIndex,
        options: *const FaissGpuMultipleClonerOptions,
        p_out: *mut *mut FaissGpuIndex,
    ) -> ::std::os::raw::c_int;
}
pub type FaissGpuParameterSpace = FaissParameterSpace_H;
pub type FaissStandardGpuResources = FaissGpuResourcesProvider_H;
extern "C" {
    pub fn faiss_StandardGpuResources_free(obj: *mut FaissStandardGpuResources);
}
extern "C" {
    #[doc = " Default constructor for StandardGpuResources"]
    pub fn faiss_StandardGpuResources_new(
        arg1: *mut *mut FaissStandardGpuResources,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Disable allocation of temporary memory; all temporary memory"]
    #[doc = " requests will call cudaMalloc / cudaFree at the point of use"]
    pub fn faiss_StandardGpuResources_noTempMemory(
        arg1: *mut FaissStandardGpuResources,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Specify that we wish to use a certain fixed size of memory on"]
    #[doc = " all devices as temporary memory"]
    pub fn faiss_StandardGpuResources_setTempMemory(
        arg1: *mut FaissStandardGpuResources,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set amount of pinned memory to allocate, for async GPU <-> CPU"]
    #[doc = " transfers"]
    pub fn faiss_StandardGpuResources_setPinnedMemory(
        arg1: *mut FaissStandardGpuResources,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Called to change the stream for work ordering"]
    pub fn faiss_StandardGpuResources_setDefaultStream(
        arg1: *mut FaissStandardGpuResources,
        device: ::std::os::raw::c_int,
        stream: cudaStream_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Called to change the work ordering streams to the null stream"]
    #[doc = " for all devices"]
    pub fn faiss_StandardGpuResources_setDefaultNullStreamAllDevices(
        arg1: *mut FaissStandardGpuResources,
    ) -> ::std::os::raw::c_int;
}
